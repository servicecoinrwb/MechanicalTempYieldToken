<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YieldWorks Dashboard - Buy/Redeem</title>
    <!-- We will use Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <!-- Ethers.js v6 -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js" type="application/javascript"></script>

    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent: #00b894; /* Teal accent */
            --border-color: #3a3a3a;
            --red: #ef4444;
            --yellow: #facc15;
            --green: #4ade80;
        }
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
        }
        .card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem; /* 12px */
            padding: 1.5rem; /* 24px */
            margin-bottom: 1.5rem;
        }
        .btn {
            display: inline-block;
            font-weight: 600;
            text-align: center;
            border-radius: 0.5rem; /* 8px */
            transition: all 0.2s ease;
            border: 2px solid transparent;
            padding: 0.6rem 1.2rem;
            cursor: pointer;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background-color: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: transparent;
            color: var(--accent);
        }
        .btn-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--bg-secondary);
            border-color: var(--text-secondary);
        }
        input[type="text"], input[type="number"], select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 0.375rem; /* 6px */
            padding: 0.5rem 0.75rem;
            width: 100%;
        }
        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(0, 184, 148, 0.3);
        }
        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.875rem; /* 14px */
            color: var(--text-secondary);
            font-weight: 500;
        }
        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }
        .alert-info { background-color: #0c4a6e; color: #bae6fd; } /* sky-900 / sky-200 */
        .alert-success { background-color: #166534; color: #bbf7d0; } /* green-800 / green-200 */
        .alert-warning { background-color: #854d0e; color: #fef08a; } /* amber-800 / amber-200 */
        .alert-error { background-color: #991b1b; color: #fecaca; } /* red-800 / red-200 */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="min-h-screen pb-16">

    <nav class="bg-secondary sticky top-0 z-50 shadow-lg mb-8">
        <div class="container mx-auto max-w-7xl p-4 flex justify-between items-center">
            <a href="#" class="text-2xl font-bold">
                YieldWorks
                <span class="text-sm font-normal text-text-secondary hidden sm:inline-block ml-2">Simple Buy/Redeem</span>
            </a>
            <div class="flex items-center space-x-4">
                 <button id="connect-button" class="btn btn-primary">Connect Wallet</button>
            </div>
        </div>
    </nav>

    <main class="container mx-auto max-w-7xl px-4">

        <!-- Status Messages -->
        <div id="status-message" class="hidden sticky top-20 z-50"></div>

        <!-- Wallet Info -->
        <div id="wallet-info" class="card hidden">
            <h2 class="text-xl font-bold mb-3">Wallet Connected</h2>
            <p class="text-sm"><strong>Network:</strong> <span id="network-name">Loading...</span></p>
            <p class="text-sm truncate"><strong>Address:</strong> <span id="user-address">Loading...</span></p>
            <!-- Added Balances Here -->
            <p class="text-sm"><strong>USDC Balance:</strong> <span id="usdc-balance">Loading...</span></p>
            <p class="text-sm"><strong>MTYLD Balance:</strong> <span id="mtyld-balance">Loading...</span></p>
        </div>

        <!-- Protocol Info (Simplified) -->
        <div id="protocol-info" class="card hidden">
            <h2 class="text-xl font-bold mb-4">Protocol Information</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                <div><strong>Token:</strong> <span id="token-name">Loading...</span> (<span id="token-symbol">---</span>)</div>
                <div><strong>Current Price:</strong> <span id="mtyld-price">Loading...</span> USDC/MTYLD</div>
                <div class="md:col-span-2"><strong>Contract Address:</strong> <a id="contract-address-link" href="#" target="_blank" rel="noopener noreferrer" class="text-accent hover:underline break-all">Loading...</a></div>
                <div><strong>Contract USDC:</strong> <span id="contract-usdc">Loading...</span> USDC</div>
                <div><strong>Available for Sale:</strong> <span id="available-mtyld">Loading...</span> MTYLD</div>
                <div><strong>Redemption Fee:</strong> <span id="redeem-fee-percent-info">Loading...</span>%</div>
            </div>
        </div>


        <!-- Buy / Redeem Section -->
        <div id="interaction-section" class="grid grid-cols-1 md:grid-cols-2 gap-6 hidden">
            <!-- Buy Card -->
            <div class="card">
                <h2 class="text-xl font-bold mb-4">Buy MTYLD</h2>
                <form id="buy-form">
                    <div class="mb-4">
                        <label for="buy-usdc-amount">USDC Amount to Spend</label>
                        <input type="number" id="buy-usdc-amount" step="0.01" min="0" placeholder="e.g., 100.00" required>
                        <p class="text-xs text-text-secondary mt-1">Your USDC Balance: <span id="buy-usdc-balance">--</span></p>
                    </div>
                     <div class="mb-4">
                        <label for="buy-slippage">Slippage Tolerance (%)</label>
                        <select id="buy-slippage" class="bg-tertiary">
                            <option value="0.5">0.5%</option>
                            <option value="1">1%</option>
                            <option value="2">2%</option>
                        </select>
                    </div>
                    <div class="mb-4 text-sm bg-tertiary p-3 rounded">
                        Estimated MTYLD to Receive: <span id="estimated-mtyld" class="font-bold">0.00</span>
                        <input type="hidden" id="min-tokens-out">
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <button type="button" id="approve-usdc-button" class="btn btn-secondary flex-1">Approve USDC</button>
                        <button type="submit" id="buy-button" class="btn btn-primary flex-1" disabled>Buy MTYLD</button>
                    </div>
                </form>
            </div>

            <!-- Redeem Card -->
            <div class="card">
                <h2 class="text-xl font-bold mb-4">Redeem MTYLD</h2>
                <form id="redeem-form">
                    <div class="mb-4">
                        <label for="redeem-mtyld-amount">MTYLD Amount to Redeem</label>
                        <input type="number" id="redeem-mtyld-amount" step="0.01" min="0" placeholder="e.g., 500.00" required>
                        <p class="text-xs text-text-secondary mt-1">Your MTYLD Balance: <span id="redeem-mtyld-balance">--</span></p>
                    </div>
                    <div class="mb-4">
                        <label for="redeem-slippage">Slippage Tolerance (%)</label>
                        <select id="redeem-slippage" class="bg-tertiary">
                            <option value="0.5">0.5%</option>
                            <option value="1">1%</option>
                            <option value="2">2%</option>
                        </select>
                    </div>
                    <div class="mb-4 text-sm bg-tertiary p-3 rounded">
                        Estimated USDC to Receive (after fee): <span id="estimated-usdc" class="font-bold">0.00</span>
                        <input type="hidden" id="min-usdc-out">
                         <p class="text-xs text-text-secondary mt-1">Redemption Fee: <span id="redeem-fee-percent-form">--</span>%</p>
                    </div>
                    <button type="submit" id="redeem-button" class="btn btn-primary w-full">Redeem MTYLD</button>
                </form>
            </div>
        </div>

    </main>

    <script type="text/javascript">
        // --- CONFIGURATION ---
        const contractAddress = "0xae2C05f01DBCC6C8AF40EbFA3339Af10dbECdFD0";
        const contractABI = [{"inputs":[{"internalType":"address","name":"initialOwner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressCallToNonContract","type":"error"},{"inputs":[],"name":"AddressEmptyRevertData","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"burner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Burn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"FeeChangeExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newFeePercentage","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"proposedAt","type":"uint256"}],"name":"FeeChangeProposed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"FeesWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"proposalId","type":"uint256"}],"name":"MintExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"proposalId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"grossYield","type":"uint256"},{"indexed":false,"internalType":"string","name":"description","type":"string"},{"indexed":false,"internalType":"uint256","name":"proposedAt","type":"uint256"}],"name":"MintProposed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"RedemptionFeeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"reserveAmount","type":"uint256"}],"name":"ReserveFunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"holder","type":"address"},{"indexed":false,"internalType":"uint256","name":"mtyldAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdcAmount","type":"uint256"}],"name":"TokensRedeemed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"}],"name":"WorkOrderCancelled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"grossYield","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"tokenizedValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"tokensIssued","type":"uint256"},{"indexed":false,"internalType":"string","name":"description","type":"string"}],"name":"WorkOrderMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":true,"internalType":"address","name":"payer","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"WorkOrderPaid","type":"event"},{"inputs":[],"name":"PROPOSAL_DELAY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"RESERVE_PERCENTAGE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TOKENIZATION_PERCENTAGE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"availableTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdcAmount","type":"uint256"},{"internalType":"uint256","name":"minTokensOut","type":"uint256"}],"name":"buyTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"workOrderId","type":"uint256"}],"name":"cancelWorkOrder","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"collectedFees","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractPaymentTokenBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"emergencyWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"executeFeeChange","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"proposalId","type":"uint256"}],"name":"executeMint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"mtyldAmount","type":"uint256"}],"name":"getRedemptionValue","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdcAmount","type":"uint256"}],"name":"getTokensForUSDC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"startId","type":"uint256"},{"internalType":"uint256","name":"endId","type":"uint256"}],"name":"getWorkOrderRange","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"grossYield","type":"uint256"},{"internalType":"uint256","name":"tokenizedValue","type":"uint256"},{"internalType":"uint256","name":"reserveAmount","type":"uint256"},{"internalType":"uint256","name":"tokensIssued","type":"uint256"},{"internalType":"bool","name":"isActive","type":"bool"},{"internalType":"bool","name":"isPaid","type":"bool"},{"internalType":"string","name":"description","type":"string"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"internalType":"struct MechanicalTempYieldToken.WorkOrder[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextProposalId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextWorkOrderId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paymentToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"workOrderId","type":"uint256"},{"internalType":"uint256","name":"payoutAmount","type":"uint256"}],"name":"payoutWorkOrder","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"pendingFeeChange","outputs":[{"internalType":"uint256","name":"newFeePercentage","type":"uint256"},{"internalType":"uint256","name":"proposedAt","type":"uint256"},{"internalType":"bool","name":"exists","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"pendingMints","outputs":[{"internalType":"uint256","name":"grossYield","type":"uint256"},{"internalType":"string","name":"description","type":"string"},{"internalType":"uint256","name":"proposedAt","type":"uint256"},{"internalType":"bool","name":"exists","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"proposeFeeChange","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"grossYield","type":"uint256"},{"internalType":"string","name":"description","type":"string"}],"name":"proposeMint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"mtyldAmount","type":"uint256"},{"internalType":"uint256","name":"minUsdcOut","type":"uint256"}],"name":"redeemTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"redemptionFeePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalReserveFund","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"workOrders","outputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"grossYield","type":"uint256"},{"internalType":"uint256","name":"tokenizedValue","type":"uint256"},{"internalType":"uint256","name":"reserveAmount","type":"uint256"},{"internalType":"uint256","name":"tokensIssued","type":"uint256"},{"internalType":"bool","name":"isActive","type":"bool"},{"internalType":"bool","name":"isPaid","type":"bool"},{"internalType":"string","name":"description","type":"string"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"stateMutability":"view","type":"function"}];
        const usdcAddress = "0xaf8d065e77c8cC2239327C5EDb3A432268e5831"; // Arbitrum Native USDC
        const arbitrumChainId = '0xa4b1'; // 42161 in hex

        // --- DOM Elements ---
        const connectButton = document.getElementById('connect-button');
        const statusMessageDiv = document.getElementById('status-message');
        const walletInfoDiv = document.getElementById('wallet-info');
        const networkNameSpan = document.getElementById('network-name');
        const userAddressSpan = document.getElementById('user-address');
        // Added back elements needed for this version
        const usdcBalanceSpan = document.getElementById('usdc-balance');
        const mtyldBalanceSpan = document.getElementById('mtyld-balance');
        const protocolInfoDiv = document.getElementById('protocol-info');
        const interactionSectionDiv = document.getElementById('interaction-section');
        const tokenNameSpan = document.getElementById('token-name');
        const tokenSymbolSpan = document.getElementById('token-symbol');
        const contractAddressLink = document.getElementById('contract-address-link');
        const contractUsdcSpan = document.getElementById('contract-usdc');
        const mtyldPriceSpan = document.getElementById('mtyld-price');
        const availableMtyldSpan = document.getElementById('available-mtyld');
        const redeemFeePercentInfoSpan = document.getElementById('redeem-fee-percent-info');

        // Buy Form Elements
        const buyForm = document.getElementById('buy-form');
        const buyUsdcAmountInput = document.getElementById('buy-usdc-amount');
        const buySlippageSelect = document.getElementById('buy-slippage');
        const estimatedMtyldSpan = document.getElementById('estimated-mtyld');
        const minTokensOutInput = document.getElementById('min-tokens-out');
        const approveUsdcButton = document.getElementById('approve-usdc-button');
        const buyButton = document.getElementById('buy-button');
        const buyUsdcBalanceSpan = document.getElementById('buy-usdc-balance'); // Moved here

        // Redeem Form Elements
        const redeemForm = document.getElementById('redeem-form');
        const redeemMtyldAmountInput = document.getElementById('redeem-mtyld-amount');
        const redeemSlippageSelect = document.getElementById('redeem-slippage');
        const estimatedUsdcSpan = document.getElementById('estimated-usdc');
        const minUsdcOutInput = document.getElementById('min-usdc-out');
        const redeemButton = document.getElementById('redeem-button');
        const redeemFeePercentFormSpan = document.getElementById('redeem-fee-percent-form'); // Moved here
        const redeemMtyldBalanceSpan = document.getElementById('redeem-mtyld-balance'); // Moved here


        // --- State Variables ---
        let provider = null;
        let signer = null;
        let userAddress = null;
        // Added back contract instances and decimals
        let mtyldContract = null;
        let usdcContract = null;
        let usdcDecimals = 6; // Default assuming USDC
        let mtyldDecimals = 18; // Default from ABI


        // --- Helper Functions ---
        function showStatus(message, type = 'info') {
             // ... (showStatus function remains the same) ...
             const el = document.createElement('div');
             el.className = `alert alert-${type}`;
             el.textContent = message;

             statusMessageDiv.innerHTML = ''; // Clear previous messages
             statusMessageDiv.appendChild(el);
             statusMessageDiv.classList.remove('hidden');

             let timeout = 5000;
             if (type === 'error' || type === 'warning') {
                 timeout = 8000; // Longer timeout for errors/warnings
             }

             setTimeout(() => {
                 el.style.transition = 'opacity 0.5s ease';
                 el.style.opacity = '0';
                 setTimeout(() => {
                     if (statusMessageDiv.contains(el)) {
                         statusMessageDiv.removeChild(el);
                     }
                     if (statusMessageDiv.children.length === 0) {
                         statusMessageDiv.classList.add('hidden');
                     }
                 }, 500);
             }, timeout);
        }
        function setLoading(button, isLoading, originalText) {
             // ... (setLoading function remains the same) ...
             if (!button) return;
             if (isLoading) {
                 button.disabled = true;
                 button.innerHTML = `<span class="loading-spinner"></span> Processing...`;
             } else {
                 button.disabled = false;
                 button.innerHTML = originalText;
             }
        }
        function shortenAddress(address) {
             // ... (shortenAddress function remains the same) ...
             if (!address) return '';
             return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
        }
         // Added back formatting functions
         function formatUnits(amount, decimals) {
             if (amount === null || amount === undefined) return '...';
             try { return ethers.formatUnits(amount, decimals); }
             catch (error) { console.error("FmtErr:", error, amount, decimals); return 'Err'; }
         }
         function parseUnits(amount, decimals) {
              try {
                  const amountStr = String(amount).trim();
                  if (!amountStr) throw new Error("Input empty");
                  return ethers.parseUnits(amountStr, decimals);
              } catch (error) {
                   console.error("ParseErr:", error, amount, decimals);
                   showStatus(`Invalid input: '${amount}'. Valid number needed.`, 'error');
                   return null;
              }
         }


        // --- Blockchain Interaction ---

        async function connectWallet() {
             // ... (connectWallet remains mostly the same, but adds contract initialization and full UI updates) ...
              if (typeof window.ethereum === 'undefined') {
                 return showStatus('MetaMask is not installed.', 'error');
             }

             const arbitrumNetwork = new ethers.Network("arbitrum", 42161);
             arbitrumNetwork.ensAddress = null;

             const connectBtn = connectButton;
             const originalConnectText = 'Connect Wallet';
             setLoading(connectBtn, true, originalConnectText);
             console.log("Attempting wallet connection...");

             try {
                 if (typeof ethers === 'undefined') { throw new Error('Ethers.js library not loaded.'); }
                 provider = new ethers.BrowserProvider(window.ethereum, arbitrumNetwork);
                 console.log("Provider created for Arbitrum (ENS disabled).");

                 if (!window.walletListenersAttached) {
                      setupWalletListeners();
                      window.walletListenersAttached = true;
                 }

                 const currentMetaMaskNetwork = await provider.getNetwork();
                 console.log("Detected MetaMask Network:", currentMetaMaskNetwork);

                 if (currentMetaMaskNetwork.chainId !== BigInt(arbitrumChainId)) {
                      console.log(`Requesting switch to Arbitrum One (Chain ID: ${arbitrumChainId})`);
                      try {
                           await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: arbitrumChainId }] });
                           provider = new ethers.BrowserProvider(window.ethereum, arbitrumNetwork);
                           console.log("Switched to Arbitrum One successfully.");
                      } catch (switchError) {
                          console.error("Switch Network Error:", switchError);
                           if (switchError.code === 4902) {
                                console.log("Arbitrum One not found, requesting add.");
                                try {
                                     await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [{ chainId: arbitrumChainId, chainName: 'Arbitrum One', nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 }, rpcUrls: ['https://arb1.arbitrum.io/rpc'], blockExplorerUrls: ['https://arbiscan.io'] }] });
                                     provider = new ethers.BrowserProvider(window.ethereum, arbitrumNetwork);
                                     console.log("Added Arbitrum One successfully.");
                                } catch (addError) {
                                     console.error("Add Network Error:", addError);
                                     throw new Error('Please add Arbitrum One network to MetaMask manually and reconnect.');
                                 }
                            } else {
                                 throw new Error('Please switch MetaMask to the Arbitrum One network.');
                             }
                      }
                 }

                 console.log("Requesting accounts...");
                 await provider.send("eth_requestAccounts", []);
                 signer = await provider.getSigner();
                 userAddress = await signer.getAddress();
                 console.log("Account connected:", userAddress);

                 // --- Initialize contracts ---
                 mtyldContract = new ethers.Contract(contractAddress, contractABI, signer);
                 const usdcAbiMinimal = ["function decimals() view returns (uint8)","function balanceOf(address) view returns (uint256)","function allowance(address, address) view returns (uint256)","function approve(address, uint256) returns (bool)"];
                 usdcContract = new ethers.Contract(usdcAddress, usdcAbiMinimal, signer);
                 console.log("Contracts initialized.");

                 // Fetch decimals
                 console.log("Fetching decimals...");
                 const [mtyldDec, usdcDec] = await Promise.all([
                     mtyldContract.decimals(),
                     usdcContract.decimals() // Assuming USDC has a standard decimals() function
                 ]).catch(decError => {
                     console.error("Error fetching decimals:", decError);
                     showStatus("Error fetching token decimals. Using defaults.", "warning");
                     return [18, 6]; // Fallback to defaults
                 });
                 mtyldDecimals = Number(mtyldDec || 18); // Use default if fetch failed
                 usdcDecimals = Number(usdcDec || 6);   // Use default if fetch failed
                 console.log(`Using Decimals: MTYLD=${mtyldDecimals}, USDC=${usdcDecimals}`);


                 connectButton.textContent = shortenAddress(userAddress);
                 connectButton.disabled = true;
                 walletInfoDiv.classList.remove('hidden');
                 protocolInfoDiv.classList.remove('hidden'); // Show protocol info
                 interactionSectionDiv.classList.remove('hidden'); // Show buy/redeem

                 console.log("Updating UI elements...");
                 await updateWalletInfo(); // Update balances
                 await updateProtocolInfo(); // Fetch and display protocol info

                 showStatus('Wallet connected successfully!', 'success');
                 console.log("Connection process complete.");

             } catch (error) {
                 console.error("Connection failed:", error);
                  let reason = error.message;
                  if (error.code === 'UNSUPPORTED_OPERATION' && error.operation?.includes('getEnsAddress')) {
                      reason = "Network configuration issue (ENS). Please try reloading.";
                  } else if (error.code === 'CALL_EXCEPTION' && error.reason) {
                     reason = error.reason;
                  } else if (error.info?.error?.message) {
                     reason = error.info.error.message;
                  }
                  showStatus(`Wallet connection failed: ${reason}`, 'error');
                 resetState();
             } finally {
                  if (userAddress) {
                       setLoading(connectBtn, false, shortenAddress(userAddress));
                       connectBtn.disabled = true;
                  } else {
                       setLoading(connectBtn, false, originalConnectText);
                       connectBtn.disabled = false;
                  }
             }
        }

        function resetState() {
             userAddress = null; signer = null; provider = null;
             mtyldContract = null; usdcContract = null; // Clear contracts
             walletInfoDiv.classList.add('hidden');
             protocolInfoDiv.classList.add('hidden'); // Hide protocol info
             interactionSectionDiv.classList.add('hidden'); // Hide buy/redeem
             networkNameSpan.textContent = 'Loading...';
             userAddressSpan.textContent = 'Loading...';
             usdcBalanceSpan.textContent = 'Loading...'; // Reset balances display
             mtyldBalanceSpan.textContent = 'Loading...';
             connectButton.textContent = 'Connect Wallet';
             connectButton.disabled = false;
             // Reset form fields and estimates
             if(buyForm) buyForm.reset();
             if(redeemForm) redeemForm.reset();
             estimatedMtyldSpan.textContent = '0.00';
             minTokensOutInput.value = '0';
             estimatedUsdcSpan.textContent = '0.00';
             minUsdcOutInput.value = '0';
             buyButton.disabled = true;
             buyUsdcBalanceSpan.textContent = '--';
             redeemMtyldBalanceSpan.textContent = '--';
             // Reset protocol info fields
             tokenNameSpan.textContent = 'Loading...';
             tokenSymbolSpan.textContent = '---';
             mtyldPriceSpan.textContent = 'Loading...';
             contractAddressLink.textContent = 'Loading...';
             contractUsdcSpan.textContent = 'Loading...';
             availableMtyldSpan.textContent = 'Loading...';
             redeemFeePercentInfoSpan.textContent = 'Loading...';
             redeemFeePercentFormSpan.textContent = '--';

        }

        // Expanded updateWalletInfo to include balances
        async function updateWalletInfo() {
             if (!provider || !userAddress || !usdcContract || !mtyldContract) return; // Need contracts now
             console.log("Updating wallet info display (including balances)...");
             try {
                const network = await provider.getNetwork();
                networkNameSpan.textContent = network.name === 'arbitrum' ? 'Arbitrum One' : network.name;
                userAddressSpan.textContent = userAddress;

                // Fetch balances
                const [usdcBal, mtyldBal] = await Promise.all([
                    usdcContract.balanceOf(userAddress),
                    mtyldContract.balanceOf(userAddress)
                ]);

                usdcBalanceSpan.textContent = `${parseFloat(formatUnits(usdcBal, usdcDecimals)).toFixed(2)} USDC`;
                mtyldBalanceSpan.textContent = `${parseFloat(formatUnits(mtyldBal, mtyldDecimals)).toFixed(4)} MTYLD`;
                buyUsdcBalanceSpan.textContent = parseFloat(formatUnits(usdcBal, usdcDecimals)).toFixed(2);
                redeemMtyldBalanceSpan.textContent = parseFloat(formatUnits(mtyldBal, mtyldDecimals)).toFixed(4);

                console.log(`Displaying Network: ${networkNameSpan.textContent}, Address: ${userAddressSpan.textContent}, USDC: ${usdcBalanceSpan.textContent}, MTYLD: ${mtyldBalanceSpan.textContent}`);
             } catch (error) {
                console.error("Error updating wallet info display:", error);
                networkNameSpan.textContent = networkNameSpan.textContent || 'Error'; // Keep if already set
                userAddressSpan.textContent = userAddressSpan.textContent || 'Error';
                usdcBalanceSpan.textContent = 'Error';
                mtyldBalanceSpan.textContent = 'Error';
                buyUsdcBalanceSpan.textContent = 'Error';
                redeemMtyldBalanceSpan.textContent = 'Error';
                showStatus("Failed to update balances.", "error");
             }
        }

        // Simplified updateProtocolInfo for Buy/Redeem context
        async function updateProtocolInfo() {
              if (!mtyldContract || !usdcContract) return;
              console.log("Updating protocol info...");
             try {
                 const [name, symbol, supply, contractUSDCBalance, available, feePercent] = await Promise.all([
                       mtyldContract.name(),
                       mtyldContract.symbol(),
                       mtyldContract.totalSupply(),
                       mtyldContract.contractPaymentTokenBalance(),
                       mtyldContract.availableTokens(),
                       mtyldContract.redemptionFeePercentage()
                  ]);

                  tokenNameSpan.textContent = name;
                  tokenSymbolSpan.textContent = symbol;
                  contractAddressLink.textContent = shortenAddress(contractAddress);
                  contractAddressLink.href = `https://arbiscan.io/address/${contractAddress}`;
                  contractUsdcSpan.textContent = parseFloat(formatUnits(contractUSDCBalance, usdcDecimals)).toFixed(2);
                  availableMtyldSpan.textContent = parseFloat(formatUnits(available, mtyldDecimals)).toFixed(4);
                  redeemFeePercentInfoSpan.textContent = feePercent.toString();
                  redeemFeePercentFormSpan.textContent = feePercent.toString();


                  let price = 0;
                  // Use contractUSDCBalance (actual USDC held) vs total supply for price
                  if (supply > 0n && contractUSDCBalance >= 0n) {
                       const scaleFactor = 10n**18n; // Scale contract balance to 18 decimals for price calc
                       const priceBigInt = supply > 0n ? (contractUSDCBalance * scaleFactor) / supply : 0n;
                       // Format the price using USDC decimals for display
                       price = parseFloat(formatUnits(priceBigInt, usdcDecimals));
                  }
                  mtyldPriceSpan.textContent = price > 0 ? price.toFixed(6) : 'N/A'; // Show N/A if no supply/balance

                  console.log(`Protocol Info Updated: Name=${name}, Symbol=${symbol}, Price=${mtyldPriceSpan.textContent}`);

                  // Update estimates based on new protocol info
                  updateBuyEstimate();
                  updateRedeemEstimate();

             } catch (error) {
                  console.error("Error updating protocol info:", error);
                  showStatus('Failed to fetch protocol data.', 'error');
                  tokenNameSpan.textContent = 'Error';
                  // etc. for other fields
             }
         }


        // --- Buy/Redeem Logic (Added Back) ---
        async function updateBuyEstimate() {
             const usdcAmountStr = buyUsdcAmountInput.value;
             if (!mtyldContract || !usdcAmountStr || parseFloat(usdcAmountStr) <= 0) {
                 estimatedMtyldSpan.textContent = '0.00'; minTokensOutInput.value = '0'; return;
             }
             const usdcAmount = parseUnits(usdcAmountStr, usdcDecimals);
             if (usdcAmount === null) { estimatedMtyldSpan.textContent = 'Invalid'; minTokensOutInput.value = '0'; return; }

             try {
                  const estimatedTokens = await mtyldContract.getTokensForUSDC(usdcAmount);
                  estimatedMtyldSpan.textContent = parseFloat(formatUnits(estimatedTokens, mtyldDecimals)).toFixed(4);
                  const slippagePercent = parseFloat(buySlippageSelect.value);
                  const slippageFactor = BigInt(Math.floor((1 - slippagePercent / 100) * 10000));
                  const minTokens = (estimatedTokens * slippageFactor) / 10000n;
                  minTokensOutInput.value = minTokens.toString();
                  // Check allowance after getting estimate
                  checkAllowanceAndEnableBuy();
             } catch (error) {
                  console.error("Buy estimate error:", error); estimatedMtyldSpan.textContent = 'Error'; minTokensOutInput.value = '0'; buyButton.disabled = true;
             }
         }

        async function updateRedeemEstimate() {
             const mtyldAmountStr = redeemMtyldAmountInput.value;
             if (!mtyldContract || !mtyldAmountStr || parseFloat(mtyldAmountStr) <= 0) {
                 estimatedUsdcSpan.textContent = '0.00'; minUsdcOutInput.value = '0'; return;
             }
             const mtyldAmount = parseUnits(mtyldAmountStr, mtyldDecimals);
             if (mtyldAmount === null) { estimatedUsdcSpan.textContent = 'Invalid'; minUsdcOutInput.value = '0'; return; }

             try {
                  const [ usdcValueBeforeFee, feePercentBigInt ] = await Promise.all([
                       mtyldContract.getRedemptionValue(mtyldAmount), mtyldContract.redemptionFeePercentage()
                  ]);
                  const feePercent = Number(feePercentBigInt);
                  redeemFeePercentFormSpan.textContent = feePercent.toString(); // Update fee display
                  const fee = (usdcValueBeforeFee * BigInt(feePercent)) / 100n;
                  const usdcToReceive = usdcValueBeforeFee >= fee ? usdcValueBeforeFee - fee : 0n;

                  estimatedUsdcSpan.textContent = parseFloat(formatUnits(usdcToReceive, usdcDecimals)).toFixed(2);
                  const slippagePercent = parseFloat(redeemSlippageSelect.value);
                  const slippageFactor = BigInt(Math.floor((1 - slippagePercent / 100) * 10000));
                  const minUsdc = (usdcToReceive * slippageFactor) / 10000n;
                  minUsdcOutInput.value = minUsdc.toString();
             } catch (error) {
                  console.error("Redeem estimate error:", error); estimatedUsdcSpan.textContent = 'Error'; minUsdcOutInput.value = '0'; redeemFeePercentFormSpan.textContent = 'Error';
             }
         }

         // Helper to check allowance and enable buy button
         async function checkAllowanceAndEnableBuy() {
             if (!usdcContract || !userAddress || !buyUsdcAmountInput.value) {
                 buyButton.disabled = true;
                 return;
             }
             const usdcAmount = parseUnits(buyUsdcAmountInput.value, usdcDecimals);
             if (usdcAmount === null || usdcAmount <= 0n) {
                 buyButton.disabled = true;
                 return;
             }
             try {
                 const allowance = await usdcContract.allowance(userAddress, contractAddress);
                 buyButton.disabled = allowance < usdcAmount;
             } catch (error) {
                 console.error("Allowance check failed:", error);
                 buyButton.disabled = true;
             }
         }

        async function handleApproveUSDC() { // Simplified, no isAdmin needed
            const button = approveUsdcButton;
             const originalText = button.textContent;
             const usdcAmountStr = buyUsdcAmountInput.value; // Only need approval for buying

             if (!usdcContract || !userAddress) return showStatus('Connect wallet first.', 'error');
             if (!usdcAmountStr || parseFloat(usdcAmountStr) <= 0) return showStatus('Enter a valid USDC amount to approve.', 'error');

             const usdcAmount = parseUnits(usdcAmountStr, usdcDecimals);
             if (usdcAmount === null) return;

             setLoading(button, true, originalText);
             showStatus('Requesting USDC approval transaction...');
             try {
                 // Check current allowance first
                 const currentAllowance = await usdcContract.allowance(userAddress, contractAddress);
                 if (currentAllowance >= usdcAmount) {
                     showStatus('Sufficient allowance already approved.', 'info');
                     buyButton.disabled = false; // Enable buy button
                     return; // Done
                 }

                 // If allowance is not zero, some wallets require resetting it first.
                 // For simplicity here, we'll just approve the needed amount. Consider max approval for better UX.
                 // const tx = await usdcContract.approve(contractAddress, ethers.MaxUint256); // Approve Max for convenience
                 const tx = await usdcContract.approve(contractAddress, usdcAmount);
                 showStatus('Approval transaction sent. Waiting for confirmation...', 'info');
                 await tx.wait();
                 showStatus('USDC approved successfully!', 'success');
                 buyButton.disabled = false; // Enable buy button after successful approval
             } catch (error) {
                 console.error("Approval failed:", error);
                 showStatus(`Approval failed: ${error?.reason || error.message || error}`, 'error');
                 buyButton.disabled = true; // Keep buy button disabled on failure
             } finally {
                 setLoading(button, false, originalText);
             }
         }

        async function handleBuyTokens(event) {
             event.preventDefault();
             if (!mtyldContract || !signer) return showStatus('Connect wallet first.', 'error');

             const usdcAmountStr = buyUsdcAmountInput.value;
             const minTokensOut = minTokensOutInput.value; // Already calculated and stored in hidden input

             if (!usdcAmountStr || parseFloat(usdcAmountStr) <= 0 || !minTokensOut || minTokensOut === '0' || minTokensOut === 'Invalid') {
                 return showStatus('Please enter a valid USDC amount and ensure an estimate is calculated.', 'error');
             }

             const usdcAmount = parseUnits(usdcAmountStr, usdcDecimals);
             if (usdcAmount === null) return; // Error handled by parseUnits
             const minTokensBigInt = BigInt(minTokensOut);

             // Double-check allowance just before sending
             try {
                 const allowance = await usdcContract.allowance(userAddress, contractAddress);
                 if (allowance < usdcAmount) {
                     buyButton.disabled = true; // Ensure button is disabled if check fails
                     return showStatus('Insufficient USDC allowance. Please approve the required amount first.', 'error');
                 }
             } catch (error) {
                 console.error("Allowance check before buy failed:", error);
                 return showStatus('Could not verify USDC allowance. Please try approving again.', 'error');
             }

             setLoading(buyButton, true, 'Buy MTYLD');
             showStatus('Sending buy transaction...');
             try {
                 const tx = await mtyldContract.buyTokens(usdcAmount, minTokensBigInt);
                 showStatus('Buy transaction sent. Waiting for confirmation...', 'info');
                 const receipt = await tx.wait();
                 console.log("Buy Transaction Receipt:", receipt);
                 showStatus('Buy successful!', 'success');
                 buyForm.reset(); // Reset form
                 estimatedMtyldSpan.textContent = '0.00'; // Reset estimate display
                 minTokensOutInput.value = '0';
                 buyButton.disabled = true; // Disable buy button until new amount/allowance check
                 await updateWalletInfo(); // Refresh balances
                 await updateProtocolInfo(); // Refresh protocol info (like available tokens, price)
             } catch (error) {
                 console.error("Buy transaction failed:", error);
                 showStatus(`Buy failed: ${error?.reason || error.message || error}`, 'error');
             } finally {
                 setLoading(buyButton, false, 'Buy MTYLD');
             }
         }

        async function handleRedeemTokens(event) {
             event.preventDefault();
             if (!mtyldContract || !signer) return showStatus('Connect wallet first.', 'error');

             const mtyldAmountStr = redeemMtyldAmountInput.value;
             const minUsdcOut = minUsdcOutInput.value; // Already calculated

             if (!mtyldAmountStr || parseFloat(mtyldAmountStr) <= 0 || !minUsdcOut || minUsdcOut === '0' || minUsdcOut === 'Invalid') {
                 return showStatus('Please enter a valid MTYLD amount and ensure an estimate is calculated.', 'error');
             }

             const mtyldAmount = parseUnits(mtyldAmountStr, mtyldDecimals);
             if (mtyldAmount === null) return;
             const minUsdcBigInt = BigInt(minUsdcOut);

             // Check balance before sending
             try {
                 const balance = await mtyldContract.balanceOf(userAddress);
                 if (balance < mtyldAmount) {
                     return showStatus('Insufficient MTYLD balance.', 'error');
                 }
             } catch(error) {
                  console.error("Balance check before redeem failed:", error);
                 return showStatus('Could not verify MTYLD balance.', 'error');
             }


             setLoading(redeemButton, true, 'Redeem MTYLD');
             showStatus('Sending redeem transaction...');
             try {
                 // No approval needed from user for redeeming MTYLD (contract burns it)
                 const tx = await mtyldContract.redeemTokens(mtyldAmount, minUsdcBigInt);
                 showStatus('Redeem transaction sent. Waiting for confirmation...', 'info');
                 const receipt = await tx.wait();
                 console.log("Redeem Transaction Receipt:", receipt);
                 showStatus('Redeem successful!', 'success');
                 redeemForm.reset(); // Reset form
                 estimatedUsdcSpan.textContent = '0.00'; // Reset estimate display
                 minUsdcOutInput.value = '0';
                 await updateWalletInfo(); // Refresh balances
                 await updateProtocolInfo(); // Refresh protocol info
             } catch (error) {
                 console.error("Redeem transaction failed:", error);
                 showStatus(`Redeem failed: ${error?.reason || error.message || error}`, 'error');
             } finally {
                 setLoading(redeemButton, false, 'Redeem MTYLD');
             }
         }


        // --- Event Listeners Setup ---
         function setupEventListeners() {
             if (window.eventListenersAttached) return;

             // Buy Form Listeners
             buyUsdcAmountInput.addEventListener('input', updateBuyEstimate);
             buySlippageSelect.addEventListener('change', updateBuyEstimate);
             approveUsdcButton.addEventListener('click', handleApproveUSDC);
             buyForm.addEventListener('submit', handleBuyTokens);

             // Redeem Form Listeners
             redeemMtyldAmountInput.addEventListener('input', updateRedeemEstimate);
             redeemSlippageSelect.addEventListener('change', updateRedeemEstimate);
             redeemForm.addEventListener('submit', handleRedeemTokens);

             // connectButton listener is added in DOMContentLoaded

             window.eventListenersAttached = true;
             console.log("Event listeners attached.");
         }

         function setupWalletListeners() {
              if (window.ethereum?.on) {
                   window.ethereum.on('accountsChanged', (accounts) => {
                       console.log('accountsChanged event:', accounts);
                       if (accounts.length === 0) {
                           showStatus('Wallet disconnected.', 'warning');
                           resetState();
                       } else if (!userAddress || accounts[0].toLowerCase() !== userAddress.toLowerCase()) {
                           showStatus('Account switched. Reconnecting...', 'info');
                           resetState();
                           connectWallet(); // Attempt to reconnect with the new account
                       }
                   });
                   window.ethereum.on('chainChanged', (chainId) => {
                       console.log('chainChanged event:', chainId);
                       if (chainId !== arbitrumChainId) {
                           showStatus('Wrong network detected. Please switch back to Arbitrum One.', 'error');
                           resetState();
                           connectButton.textContent = 'Wrong Network'; // Keep button indicating wrong network
                           connectButton.disabled = true;
                       } else {
                           if (userAddress) {
                               showStatus('Network switched back to Arbitrum One. Refreshing...', 'info');
                               connectWallet();
                           } else {
                               showStatus('Arbitrum One detected. Please connect wallet.', 'info');
                               resetState();
                           }
                       }
                   });
             } else {
                 console.warn("MetaMask event listeners ('on' method) not available.");
             }
         }


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Loaded. Adding connect button listener and setting up other listeners.");
             connectButton.addEventListener('click', connectWallet);
             setupEventListeners(); // Setup listeners for buy/redeem forms etc.
        });

    </script>
</body>
</html>

