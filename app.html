<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YieldWorks Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <!-- Ethers.js v6 - Updated CDN Link -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js" type="application/javascript"></script>

    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent: #00b894; /* Teal accent */
            --border-color: #3a3a3a;
        }
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
        }
        .card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem; /* 12px */
            padding: 1.5rem; /* 24px */
            margin-bottom: 1.5rem;
        }
        .btn {
            display: inline-block;
            font-weight: 600;
            text-align: center;
            border-radius: 0.5rem; /* 8px */
            transition: all 0.2s ease;
            border: 2px solid transparent;
            padding: 0.6rem 1.2rem;
            cursor: pointer;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background-color: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: transparent;
            color: var(--accent);
        }
        .btn-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--bg-secondary);
            border-color: var(--text-secondary);
        }
         .btn-danger {
            background-color: #ef4444; /* red-500 */
            color: white;
            border-color: #ef4444;
         }
         .btn-danger:hover:not(:disabled) {
            background-color: #dc2626; /* red-600 */
            border-color: #dc2626;
         }
        input[type="text"], input[type="number"], input[type="password"], textarea, select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 0.375rem; /* 6px */
            padding: 0.5rem 0.75rem;
            width: 100%;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(0, 184, 148, 0.3);
        }
        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.875rem; /* 14px */
            color: var(--text-secondary);
            font-weight: 500;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            font-size: 0.875rem;
        }
        th {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        tbody tr:last-child td {
            border-bottom: none;
        }
        tbody tr:hover {
            background-color: var(--bg-tertiary);
        }
        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }
        .alert-info { background-color: #0c4a6e; color: #bae6fd; } /* sky-900 / sky-200 */
        .alert-success { background-color: #166534; color: #bbf7d0; } /* green-800 / green-200 */
        .alert-error { background-color: #991b1b; color: #fecaca; } /* red-800 / red-200 */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom styles for filter selects */
        .filter-select {
             background-color: var(--bg-tertiary);
             border: 1px solid var(--border-color);
             color: var(--text-primary);
             border-radius: 0.375rem; /* 6px */
             padding: 0.5rem 0.75rem;
             height: 42px; /* Match input height */
        }
         .filter-select:focus {
             outline: none;
             border-color: var(--accent);
             box-shadow: 0 0 0 2px rgba(0, 184, 148, 0.3);
         }
    </style>
</head>
<body class="min-h-screen pb-16">

    <nav class="bg-secondary sticky top-0 z-50 shadow-lg mb-8">
        <div class="container mx-auto max-w-7xl p-4 flex justify-between items-center">
            <a href="index.html" class="text-2xl font-bold">
                YieldWorks
                <span class="text-sm font-normal text-secondary hidden sm:inline-block ml-2">Dashboard</span>
            </a>
            <button id="connect-button" class="btn btn-primary">Connect Wallet</button>
        </div>
    </nav>

    <main class="container mx-auto max-w-7xl px-4">

        <!-- Status Messages -->
        <div id="status-message" class="hidden"></div>

        <!-- Wallet Info -->
        <div id="wallet-info" class="card hidden">
            <h2 class="text-xl font-bold mb-3">Wallet Connected</h2>
            <p class="text-sm"><strong>Network:</strong> <span id="network-name"></span></p>
            <p class="text-sm truncate"><strong>Address:</strong> <span id="user-address"></span></p>
            <p class="text-sm"><strong>USDC Balance:</strong> <span id="usdc-balance">Loading...</span></p>
            <p class="text-sm"><strong>MTYLD Balance:</strong> <span id="mtyld-balance">Loading...</span></p>
        </div>

        <!-- Protocol Info -->
        <div class="card">
            <h2 class="text-xl font-bold mb-4">Protocol Information</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
                <div><strong>Token:</strong> <span id="token-name">Loading...</span> (<span id="token-symbol">---</span>)</div>
                <div><strong>Total Supply:</strong> <span id="total-supply">Loading...</span> MTYLD</div>
                <div class="md:col-span-2 lg:col-span-1"><strong>Contract Address:</strong> <a id="contract-address-link" href="#" target="_blank" rel="noopener noreferrer" class="text-accent hover:underline break-all">Loading...</a></div>
                <div><strong>Contract USDC:</strong> <span id="contract-usdc">Loading...</span> USDC</div>
                <div><strong>Current Price:</strong> <span id="mtyld-price">Loading...</span> USDC/MTYLD</div>
                <div><strong>Available for Sale:</strong> <span id="available-mtyld">Loading...</span> MTYLD</div>
            </div>
        </div>

        <!-- Buy / Redeem Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Buy Card -->
            <div class="card">
                <h2 class="text-xl font-bold mb-4">Buy MTYLD</h2>
                <form id="buy-form">
                    <div class="mb-4">
                        <label for="buy-usdc-amount">USDC Amount to Spend</label>
                        <input type="number" id="buy-usdc-amount" step="0.01" min="0" placeholder="e.g., 100.00" required>
                        <p class="text-xs text-secondary mt-1">Your USDC Balance: <span id="buy-usdc-balance">--</span></p>
                    </div>
                     <div class="mb-4">
                        <label for="buy-slippage">Slippage Tolerance (%)</label>
                        <select id="buy-slippage" class="bg-tertiary">
                            <option value="0.5">0.5%</option>
                            <option value="1">1%</option>
                            <option value="2">2%</option>
                        </select>
                    </div>
                    <div class="mb-4 text-sm bg-tertiary p-3 rounded">
                        Estimated MTYLD to Receive: <span id="estimated-mtyld" class="font-bold">0.00</span>
                        <input type="hidden" id="min-tokens-out">
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <button type="button" id="approve-usdc-button" class="btn btn-secondary flex-1">Approve USDC</button>
                        <button type="submit" id="buy-button" class="btn btn-primary flex-1" disabled>Buy MTYLD</button>
                    </div>
                </form>
            </div>

            <!-- Redeem Card -->
            <div class="card">
                <h2 class="text-xl font-bold mb-4">Redeem MTYLD</h2>
                <form id="redeem-form">
                    <div class="mb-4">
                        <label for="redeem-mtyld-amount">MTYLD Amount to Redeem</label>
                        <input type="number" id="redeem-mtyld-amount" step="0.01" min="0" placeholder="e.g., 500.00" required>
                        <p class="text-xs text-secondary mt-1">Your MTYLD Balance: <span id="redeem-mtyld-balance">--</span></p>
                    </div>
                    <div class="mb-4">
                        <label for="redeem-slippage">Slippage Tolerance (%)</label>
                        <select id="redeem-slippage" class="bg-tertiary">
                            <option value="0.5">0.5%</option>
                            <option value="1">1%</option>
                            <option value="2">2%</option>
                        </select>
                    </div>
                    <div class="mb-4 text-sm bg-tertiary p-3 rounded">
                        Estimated USDC to Receive (after fee): <span id="estimated-usdc" class="font-bold">0.00</span>
                        <input type="hidden" id="min-usdc-out">
                         <p class="text-xs text-secondary mt-1">Redemption Fee: <span id="redeem-fee-percent">--</span>%</p>
                    </div>
                    <button type="submit" id="redeem-button" class="btn btn-primary w-full">Redeem MTYLD</button>
                </form>
            </div>
        </div>

        <!-- Work Orders Table Section -->
         <div class="card mt-6">
             <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                 <h2 class="text-xl font-bold mb-3 sm:mb-0">Recent Work Orders</h2>
                 <!-- Filter UI -->
                 <div class="flex items-center space-x-3">
                     <label for="filter-month" class="text-sm text-secondary whitespace-nowrap">Filter by:</label>
                     <select id="filter-month" class="filter-select w-32">
                         <option value="all">All Months</option>
                         <option value="0">January</option>
                         <option value="1">February</option>
                         <option value="2">March</option>
                         <option value="3">April</option>
                         <option value="4">May</option>
                         <option value="5">June</option>
                         <option value="6">July</option>
                         <option value="7">August</option>
                         <option value="8">September</option>
                         <option value="9">October</option>
                         <option value="10">November</option>
                         <option value="11">December</option>
                     </select>
                     <select id="filter-year" class="filter-select w-28">
                         <option value="all">All Years</option>
                         <!-- Year options will be added dynamically -->
                     </select>
                 </div>
             </div>
             <div class="overflow-x-auto">
                 <table id="work-orders-table">
                     <thead>
                         <tr>
                             <th>ID</th>
                             <th>Description</th>
                             <th>Yield (USDC)</th>
                             <th>Reserve (USDC)</th>
                             <th>Issued (MTYLD)</th>
                             <th>Status</th>
                             <th>Created</th>
                         </tr>
                     </thead>
                     <tbody id="work-orders-body">
                         <tr><td colspan="7" class="text-center py-4 text-secondary">Loading work orders...</td></tr>
                         <!-- Rows will be added dynamically -->
                     </tbody>
                 </table>
             </div>
             <!-- Note: Load More button is now less relevant if we fetch all for filtering, consider removing or changing its logic -->
              <!-- <div class="mt-4 text-center">
                   <button id="load-more-orders" class="btn btn-secondary text-sm hidden">Load More</button>
               </div> -->
         </div>


        <!-- Admin Panel (Initially hidden) -->
        <div id="admin-panel" class="card mt-8 hidden">
            <h2 class="text-2xl font-bold mb-6 text-center text-accent">Admin Panel</h2>

             <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Mint Work Order -->
                <form id="mint-order-form" class="bg-tertiary p-4 rounded-lg border border-border-color">
                    <h3 class="text-lg font-semibold mb-3">Mint New Work Order</h3>
                    <div class="mb-3">
                        <label for="mint-yield">Gross Yield (USDC)</label>
                        <input type="number" id="mint-yield" step="0.01" min="0.01" placeholder="e.g., 1000.00" required>
                    </div>
                    <div class="mb-3">
                        <label for="mint-desc">Description</label>
                        <input type="text" id="mint-desc" placeholder="e.g., Commercial HVAC Install #12345" required>
                    </div>
                    <button type="submit" class="btn btn-primary w-full">Mint Order</button>
                </form>

                 <!-- Payout Work Order -->
                 <form id="payout-order-form" class="bg-tertiary p-4 rounded-lg border border-border-color">
                     <h3 class="text-lg font-semibold mb-3">Payout Work Order</h3>
                      <div class="mb-3">
                        <label for="payout-id">Work Order ID</label>
                        <input type="number" id="payout-id" min="1" placeholder="e.g., 1" required>
                    </div>
                    <div class="mb-3">
                        <label for="payout-amount">Payout Amount (USDC)</label>
                        <input type="number" id="payout-amount" step="0.01" min="0.01" placeholder="e.g., 1000.00 (Should match Gross Yield)" required>
                    </div>
                     <p class="text-xs text-secondary mb-3">Note: You must approve the contract to spend your USDC before payout.</p>
                      <div class="flex gap-3">
                           <button type="button" id="admin-approve-usdc-button" class="btn btn-secondary flex-1">Approve USDC</button>
                           <button type="submit" class="btn btn-primary flex-1">Submit Payout</button>
                      </div>
                 </form>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                 <!-- Cancel Work Order -->
                 <form id="cancel-order-form" class="bg-tertiary p-4 rounded-lg border border-border-color">
                     <h3 class="text-lg font-semibold mb-3">Cancel Work Order</h3>
                     <div class="mb-3">
                         <label for="cancel-id">Work Order ID</label>
                         <input type="number" id="cancel-id" min="1" placeholder="e.g., 1" required>
                     </div>
                     <button type="submit" class="btn btn-danger w-full">Cancel Order</button>
                 </form>

                <!-- Set Redemption Fee -->
                <form id="set-fee-form" class="bg-tertiary p-4 rounded-lg border border-border-color">
                    <h3 class="text-lg font-semibold mb-3">Set Redemption Fee</h3>
                    <div class="mb-3">
                        <label for="new-fee">New Fee Percentage (0-20)</label>
                        <input type="number" id="new-fee" min="0" max="20" step="0.1" placeholder="e.g., 10" required>
                    </div>
                     <p class="text-xs text-secondary mb-3">Current Fee: <span id="current-redeem-fee">--</span>%</p>
                    <button type="submit" class="btn btn-secondary w-full">Update Fee</button>
                </form>

                 <!-- Withdraw Fees -->
                <div class="bg-tertiary p-4 rounded-lg border border-border-color">
                     <h3 class="text-lg font-semibold mb-3">Withdraw Fees</h3>
                     <p class="text-sm mb-3">Collected Fees: <span id="collected-fees" class="font-bold">Loading...</span> USDC</p>
                    <button id="withdraw-fees-button" class="btn btn-secondary w-full" disabled>Withdraw All Fees</button>
                 </div>
            </div>
             <!-- Emergency Withdraw -->
             <form id="emergency-withdraw-form" class="bg-tertiary p-4 rounded-lg border border-border-color mt-6">
                 <h3 class="text-lg font-semibold mb-3">Emergency Withdraw (Owner Only)</h3>
                 <p class="text-xs text-secondary mb-3">Withdraw ERC20 tokens accidentally sent to this contract.</p>
                 <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
                     <div>
                         <label for="emergency-token">Token Address</label>
                         <input type="text" id="emergency-token" placeholder="0x..." required>
                     </div>
                     <div>
                         <label for="emergency-to">Recipient Address</label>
                         <input type="text" id="emergency-to" placeholder="0x..." required>
                     </div>
                      <div>
                         <label for="emergency-amount">Amount (Raw Units)</label>
                         <input type="number" id="emergency-amount" min="1" placeholder="e.g., 1000000000000000000" required>
                     </div>
                 </div>
                 <button type="submit" class="btn btn-danger w-full mt-3">Withdraw Token</button>
             </form>
        </div>

    </main>

    <script type="text/javascript">
        // --- CONFIGURATION ---
        const contractAddress = "0xB911E622Aaf41F068c561cca67ae3f5d8Bf92826";
        const contractABI = [{"inputs":[{"internalType":"address","name":"initialOwner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressCallToNonContract","type":"error"},{"inputs":[],"name":"AddressEmptyRevertData","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"FeesWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"RedemptionFeeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ReserveFunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"holder","type":"address"},{"indexed":false,"internalType":"uint256","name":"mtyldAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdcAmount","type":"uint256"}],"name":"TokensRedeemed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"}],"name":"WorkOrderCancelled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"yieldAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"tokensIssued","type":"uint256"},{"indexed":false,"internalType":"string","name":"description","type":"string"}],"name":"WorkOrderMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":true,"internalType":"address","name":"payer","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"WorkOrderPaid","type":"event"},{"inputs":[],"name":"RESERVE_PERCENTAGE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"availableTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdcAmount","type":"uint256"},{"internalType":"uint256","name":"minTokensOut","type":"uint256"}],"name":"buyTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"workOrderId","type":"uint256"}],"name":"cancelWorkOrder","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"collectedFees","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractPaymentTokenBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"emergencyWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"mtyldAmount","type":"uint256"}],"name":"getRedemptionValue","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdcAmount","type":"uint256"}],"name":"getTokensForUSDC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"grossYield","type":"uint256"},{"internalType":"string","name":"description","type":"string"}],"name":"mintFromWorkOrder","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextWorkOrderId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paymentToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"workOrderId","type":"uint256"},{"internalType":"uint256","name":"payoutAmount","type":"uint256"}],"name":"payoutWorkOrder","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"mtyldAmount","type":"uint256"},{"internalType":"uint256","name":"minUsdcOut","type":"uint256"}],"name":"redeemTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"redemptionFeePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"setRedemptionFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalReserveFund","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"workOrders","outputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"grossYield","type":"uint256"},{"internalType":"uint256","name":"reserveAmount","type":"uint256"},{"internalType":"uint256","name":"tokensIssued","type":"uint256"},{"internalType":"bool","name":"isActive","type":"bool"},{"internalType":"bool","name":"isPaid","type":"bool"},{"internalType":"string","name":"description","type":"string"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"stateMutability":"view","type":"function"}];
        const usdcAddress = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"; // Arbitrum Native USDC
        const arbitrumChainId = '0xa4b1'; // 42161 in hex

        // --- DOM Elements ---
        const connectButton = document.getElementById('connect-button');
        const statusMessageDiv = document.getElementById('status-message');
        const walletInfoDiv = document.getElementById('wallet-info');
        const networkNameSpan = document.getElementById('network-name');
        const userAddressSpan = document.getElementById('user-address');
        const usdcBalanceSpan = document.getElementById('usdc-balance');
        const mtyldBalanceSpan = document.getElementById('mtyld-balance');
        const buyUsdcBalanceSpan = document.getElementById('buy-usdc-balance');
        const redeemMtyldBalanceSpan = document.getElementById('redeem-mtyld-balance');

        // Protocol Info Elements
        const tokenNameSpan = document.getElementById('token-name');
        const tokenSymbolSpan = document.getElementById('token-symbol');
        const totalSupplySpan = document.getElementById('total-supply');
        const contractAddressLink = document.getElementById('contract-address-link');
        const contractUsdcSpan = document.getElementById('contract-usdc');
        const mtyldPriceSpan = document.getElementById('mtyld-price');
        const availableMtyldSpan = document.getElementById('available-mtyld');

        // Buy Form Elements
        const buyForm = document.getElementById('buy-form');
        const buyUsdcAmountInput = document.getElementById('buy-usdc-amount');
        const buySlippageSelect = document.getElementById('buy-slippage');
        const estimatedMtyldSpan = document.getElementById('estimated-mtyld');
        const minTokensOutInput = document.getElementById('min-tokens-out');
        const approveUsdcButton = document.getElementById('approve-usdc-button');
        const buyButton = document.getElementById('buy-button');

        // Redeem Form Elements
        const redeemForm = document.getElementById('redeem-form');
        const redeemMtyldAmountInput = document.getElementById('redeem-mtyld-amount');
        const redeemSlippageSelect = document.getElementById('redeem-slippage');
        const estimatedUsdcSpan = document.getElementById('estimated-usdc');
        const minUsdcOutInput = document.getElementById('min-usdc-out');
        const redeemButton = document.getElementById('redeem-button');
        const redeemFeePercentSpan = document.getElementById('redeem-fee-percent');


        // Work Orders Elements
        const workOrdersTableBody = document.getElementById('work-orders-body');
        // const loadMoreOrdersButton = document.getElementById('load-more-orders'); // Commented out - less relevant now
        const filterMonthSelect = document.getElementById('filter-month');
        const filterYearSelect = document.getElementById('filter-year');


        // Admin Panel Elements
        const adminPanelDiv = document.getElementById('admin-panel');
        const mintOrderForm = document.getElementById('mint-order-form');
        const payoutOrderForm = document.getElementById('payout-order-form');
        const cancelOrderForm = document.getElementById('cancel-order-form');
        const setFeeForm = document.getElementById('set-fee-form');
        const currentRedeemFeeSpan = document.getElementById('current-redeem-fee');
        const collectedFeesSpan = document.getElementById('collected-fees');
        const withdrawFeesButton = document.getElementById('withdraw-fees-button');
        const adminApproveUsdcButton = document.getElementById('admin-approve-usdc-button');
        const emergencyWithdrawForm = document.getElementById('emergency-withdraw-form');

        // --- State Variables ---
        let provider = null;
        let signer = null;
        let userAddress = null;
        let mtyldContract = null;
        let usdcContract = null;
        let contractOwner = null;
        let usdcDecimals = 6; // Assume 6, will be confirmed
        let mtyldDecimals = 18; // From contract
        // let ordersToLoad = 10; // Commented out - less relevant now
        let allWorkOrders = []; // Store all fetched orders here
        let availableYears = new Set(); // To populate year filter


        // --- Helper Functions ---

        // Display status messages (info, success, error)
        function showStatus(message, type = 'info') {
            statusMessageDiv.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            statusMessageDiv.classList.remove('hidden');
            // Auto-hide after 5 seconds for success/info
            if (type !== 'error') {
                setTimeout(() => {
                    statusMessageDiv.classList.add('hidden');
                }, 5000);
            }
        }

        // Format BigInt amounts to readable strings
         function formatUnits(amount, decimals) {
            if (amount === null || amount === undefined) return '...';
            try {
                 const formatted = ethers.formatUnits(amount, decimals);
                 return formatted;
            } catch (error) {
                 console.error("Error formatting units:", error, "Amount:", amount, "Decimals:", decimals);
                 return 'Error';
            }
         }

        // Parse user input strings to BigInt
         function parseUnits(amount, decimals) {
             try {
                const amountStr = String(amount).trim();
                if (!amountStr) {
                    throw new Error("Input amount is empty");
                }
                return ethers.parseUnits(amountStr, decimals);
             } catch (error) {
                 console.error("Error parsing units:", error, "Amount:", amount, "Decimals:", decimals);
                 showStatus(`Invalid input: '${amount}'. Please enter a valid number.`, 'error');
                 return null;
             }
         }

        // Format date from timestamp AND extract month/year
        function formatDate(timestamp) {
            if (!timestamp || timestamp === 0n) return { dateStr: 'N/A', month: -1, year: -1 };
            try {
                const date = new Date(Number(timestamp) * 1000);
                 const dateStr = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                 const month = date.getMonth(); // 0-11
                 const year = date.getFullYear();
                 return { dateStr, month, year };
            } catch {
                return { dateStr: 'Invalid Date', month: -1, year: -1 };
            }
        }


        // Add loading indicator to a button
        function setLoading(button, isLoading, originalText) {
            if (!button) return; // Add null check
            if (isLoading) {
                button.disabled = true;
                button.innerHTML = `<span class="loading-spinner"></span> Processing...`;
            } else {
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        // Shorten address
        function shortenAddress(address) {
            if (!address) return '';
            return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
        }


        // --- Blockchain Interaction ---

        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                return showStatus('MetaMask is not installed. Please install it to use this app.', 'error');
            }

             const connectBtn = document.getElementById('connect-button'); // Get button reference
             const originalConnectText = 'Connect Wallet';
             setLoading(connectBtn, true, originalConnectText); // Show loading state

            try {
                // Use ethers v6 provider
                if (typeof ethers === 'undefined') {
                    setLoading(connectBtn, false, originalConnectText);
                    return showStatus('Ethers.js library not loaded. Please refresh the page.', 'error');
                }
                provider = new ethers.BrowserProvider(window.ethereum);

                // Check network
                const network = await provider.getNetwork();
                if (network.chainId !== BigInt(arbitrumChainId)) {
                     try {
                          // Try switching to Arbitrum
                           await window.ethereum.request({
                               method: 'wallet_switchEthereumChain',
                               params: [{ chainId: arbitrumChainId }],
                           });
                           provider = new ethers.BrowserProvider(window.ethereum);
                     } catch (switchError) {
                          if (switchError.code === 4902) {
                                try {
                                    await window.ethereum.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [{ chainId: arbitrumChainId, chainName: 'Arbitrum One', nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 }, rpcUrls: ['https://arb1.arbitrum.io/rpc'], blockExplorerUrls: ['https://arbiscan.io'] }],
                                    });
                                     provider = new ethers.BrowserProvider(window.ethereum);
                                } catch (addError) {
                                     console.error("Failed to add Arbitrum network:", addError);
                                     setLoading(connectBtn, false, originalConnectText);
                                     return showStatus('Please add the Arbitrum One network to MetaMask manually.', 'error');
                                }
                           } else {
                                console.error("Failed to switch network:", switchError);
                                setLoading(connectBtn, false, originalConnectText);
                                return showStatus('Please switch to the Arbitrum One network in MetaMask.', 'error');
                           }
                     }
                }

                 await provider.send("eth_requestAccounts", []);
                signer = await provider.getSigner();
                userAddress = await signer.getAddress();

                mtyldContract = new ethers.Contract(contractAddress, contractABI, signer);
                 const usdcAbiMinimal = [
                     "function decimals() view returns (uint8)",
                     "function balanceOf(address account) view returns (uint256)",
                     "function allowance(address owner, address spender) view returns (uint256)",
                     "function approve(address spender, uint256 amount) returns (bool)",
                     "function transferFrom(address sender, address recipient, uint256 amount) returns (bool)"
                 ];
                usdcContract = new ethers.Contract(usdcAddress, usdcAbiMinimal, signer);
                usdcDecimals = await usdcContract.decimals();

                connectButton.textContent = shortenAddress(userAddress);
                connectButton.disabled = true;
                walletInfoDiv.classList.remove('hidden');

                // Fetch initial data
                await updateWalletInfo();
                await updateProtocolInfo();
                await fetchAndStoreAllWorkOrders(); // Fetch all orders initially
                await checkAdminStatus();

                 showStatus('Wallet connected successfully!', 'success');
                setupEventListeners();

            } catch (error) {
                console.error("Connection failed:", error);
                showStatus(`Wallet connection failed: ${error.message}`, 'error');
                 setLoading(connectBtn, false, originalConnectText);
                 connectButton.disabled = false;
            } finally {
                 if (connectButton.disabled && connectButton.textContent !== shortenAddress(userAddress)) {
                      setLoading(connectBtn, false, originalConnectText);
                      connectButton.disabled = false;
                 } else if (!connectButton.disabled && userAddress) {
                      connectButton.textContent = shortenAddress(userAddress);
                      connectButton.disabled = true;
                 }
            }
        }

        async function checkAdminStatus() {
            if (!mtyldContract) return; // Add check
            try {
                contractOwner = await mtyldContract.owner();
                if (userAddress && contractOwner && userAddress.toLowerCase() === contractOwner.toLowerCase()) {
                    adminPanelDiv.classList.remove('hidden');
                    console.log("Admin connected");
                    await updateAdminInfo();
                } else {
                     adminPanelDiv.classList.add('hidden');
                     console.log("Connected user is not the admin");
                }
            } catch (error) {
                console.error("Error checking admin status:", error);
                 showStatus('Could not verify admin status.', 'error');
            }
        }

        async function updateAdminInfo() {
             if (!mtyldContract) return; // Add check
             try {
                  const fees = await mtyldContract.collectedFees();
                  collectedFeesSpan.textContent = parseFloat(formatUnits(fees, usdcDecimals)).toFixed(2);
                  withdrawFeesButton.disabled = fees === 0n;

                  const feePercent = await mtyldContract.redemptionFeePercentage();
                  currentRedeemFeeSpan.textContent = feePercent.toString();

             } catch (error) {
                  console.error("Error fetching admin info:", error);
                  collectedFeesSpan.textContent = 'Error';
                  withdrawFeesButton.disabled = true;
             }
        }

        async function updateWalletInfo() {
            if (!provider || !userAddress || !usdcContract || !mtyldContract) return;

            try {
                const network = await provider.getNetwork();
                networkNameSpan.textContent = network.name === 'arbitrum' ? 'Arbitrum One' : network.name;
                userAddressSpan.textContent = userAddress;

                const usdcBal = await usdcContract.balanceOf(userAddress);
                const mtyldBal = await mtyldContract.balanceOf(userAddress);

                usdcBalanceSpan.textContent = `${parseFloat(formatUnits(usdcBal, Number(usdcDecimals))).toFixed(2)} USDC`;
                mtyldBalanceSpan.textContent = `${parseFloat(formatUnits(mtyldBal, mtyldDecimals)).toFixed(4)} MTYLD`;

                buyUsdcBalanceSpan.textContent = parseFloat(formatUnits(usdcBal, Number(usdcDecimals))).toFixed(2);
                redeemMtyldBalanceSpan.textContent = parseFloat(formatUnits(mtyldBal, mtyldDecimals)).toFixed(4);

            } catch (error) {
                console.error("Error updating wallet info:", error);
                showStatus('Failed to update wallet balances.', 'error');
                usdcBalanceSpan.textContent = 'Error';
                mtyldBalanceSpan.textContent = 'Error';
            }
        }

        async function updateProtocolInfo() {
             if (!mtyldContract || !usdcContract) return;

             try {
                 const name = await mtyldContract.name();
                 const symbol = await mtyldContract.symbol();
                 const supply = await mtyldContract.totalSupply();
                 const contractUSDCBalance = await mtyldContract.contractPaymentTokenBalance();
                 const available = await mtyldContract.availableTokens();
                 const feePercent = await mtyldContract.redemptionFeePercentage();


                 tokenNameSpan.textContent = name;
                 tokenSymbolSpan.textContent = symbol;
                 totalSupplySpan.textContent = parseFloat(formatUnits(supply, mtyldDecimals)).toFixed(4);
                 contractAddressLink.textContent = shortenAddress(contractAddress);
                 contractAddressLink.href = `https://arbiscan.io/address/${contractAddress}`;
                 contractUsdcSpan.textContent = parseFloat(formatUnits(contractUSDCBalance, Number(usdcDecimals))).toFixed(2);
                 availableMtyldSpan.textContent = parseFloat(formatUnits(available, mtyldDecimals)).toFixed(4);
                 redeemFeePercentSpan.textContent = feePercent.toString();


                 let price = 0;
                 if (supply > 0n && contractUSDCBalance >= 0n) {
                      const scaleFactor = 10n ** BigInt(18 - Number(usdcDecimals));
                      const priceBigInt = (contractUSDCBalance * scaleFactor) / supply;
                      price = parseFloat(formatUnits(priceBigInt, Number(usdcDecimals)));
                 }
                 mtyldPriceSpan.textContent = price > 0 ? price.toFixed(6) : '0.000000';

                 updateBuyEstimate();
                 updateRedeemEstimate();

             } catch (error) {
                 console.error("Error updating protocol info:", error);
                 showStatus('Failed to fetch protocol data.', 'error');
                 tokenNameSpan.textContent = 'Error';
                 // etc.
             }
         }


        // --- Buy/Redeem Logic ---

         async function updateBuyEstimate() {
             const usdcAmountStr = buyUsdcAmountInput.value;
             if (!mtyldContract || !usdcAmountStr || parseFloat(usdcAmountStr) <= 0) {
                 estimatedMtyldSpan.textContent = '0.00';
                 minTokensOutInput.value = '0';
                 return;
             }

             const usdcAmount = parseUnits(usdcAmountStr, Number(usdcDecimals));
             if (usdcAmount === null) {
                  estimatedMtyldSpan.textContent = 'Invalid Input';
                  minTokensOutInput.value = '0';
                  return;
             }

             try {
                  const estimatedTokens = await mtyldContract.getTokensForUSDC(usdcAmount);
                  estimatedMtyldSpan.textContent = parseFloat(formatUnits(estimatedTokens, mtyldDecimals)).toFixed(4);

                  const slippagePercent = parseFloat(buySlippageSelect.value);
                  const slippageFactor = BigInt(Math.floor((1 - slippagePercent / 100) * 10000));
                  const minTokens = (estimatedTokens * slippageFactor) / 10000n;
                  minTokensOutInput.value = minTokens.toString();
             } catch (error) {
                  console.error("Error getting buy estimate:", error);
                  estimatedMtyldSpan.textContent = 'Error';
                  minTokensOutInput.value = '0';
             }
         }

        async function updateRedeemEstimate() {
            const mtyldAmountStr = redeemMtyldAmountInput.value;
             if (!mtyldContract || !mtyldAmountStr || parseFloat(mtyldAmountStr) <= 0) {
                 estimatedUsdcSpan.textContent = '0.00';
                 minUsdcOutInput.value = '0';
                 return;
             }

             const mtyldAmount = parseUnits(mtyldAmountStr, mtyldDecimals);
              if (mtyldAmount === null) {
                   estimatedUsdcSpan.textContent = 'Invalid Input';
                   minUsdcOutInput.value = '0';
                   return;
              }

             try {
                  const [ usdcValueBeforeFee, feePercentBigInt ] = await Promise.all([
                       mtyldContract.getRedemptionValue(mtyldAmount),
                       mtyldContract.redemptionFeePercentage()
                  ]);

                  const feePercent = Number(feePercentBigInt);
                  const fee = (usdcValueBeforeFee * BigInt(feePercent)) / 100n;
                  const usdcToReceive = usdcValueBeforeFee - fee;

                  estimatedUsdcSpan.textContent = parseFloat(formatUnits(usdcToReceive, Number(usdcDecimals))).toFixed(2);

                  const slippagePercent = parseFloat(redeemSlippageSelect.value);
                  const slippageFactor = BigInt(Math.floor((1 - slippagePercent / 100) * 10000));
                  const minUsdc = (usdcToReceive * slippageFactor) / 10000n;
                  minUsdcOutInput.value = minUsdc.toString();
             } catch (error) {
                 console.error("Error getting redeem estimate:", error);
                 estimatedUsdcSpan.textContent = 'Error';
                 minUsdcOutInput.value = '0';
             }
         }


        async function handleApproveUSDC(isAdmin = false) {
             const amountInput = isAdmin ? document.getElementById('payout-amount') : buyUsdcAmountInput;
             const button = isAdmin ? adminApproveUsdcButton : approveUsdcButton;
             const originalText = button.textContent;

             const usdcAmountStr = amountInput.value;
             if (!usdcAmountStr || parseFloat(usdcAmountStr) <= 0) {
                 return showStatus('Please enter a valid USDC amount to approve.', 'error');
             }

             const usdcAmount = parseUnits(usdcAmountStr, Number(usdcDecimals));
              if (usdcAmount === null) return;

             setLoading(button, true, originalText);
             showStatus('Requesting USDC approval from your wallet...');

             try {
                const currentAllowance = await usdcContract.allowance(userAddress, contractAddress);
                if (currentAllowance >= usdcAmount) {
                    showStatus('Sufficient allowance already approved.', 'info');
                    if (!isAdmin) buyButton.disabled = false;
                    return;
                }

                 const tx = await usdcContract.approve(contractAddress, usdcAmount);
                 showStatus('Approval transaction sent. Waiting for confirmation...', 'info');
                 await tx.wait();
                 showStatus('USDC approved successfully! You can now proceed.', 'success');
                  if(!isAdmin) buyButton.disabled = false;
             } catch (error) {
                 console.error("Approval failed:", error);
                 showStatus(`USDC approval failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
             } finally {
                 setLoading(button, false, originalText);
             }
         }

        async function handleBuyTokens(event) {
            event.preventDefault();
            if (!mtyldContract || !signer) return showStatus('Please connect wallet first.', 'error');

            const usdcAmountStr = buyUsdcAmountInput.value;
            const minTokensOut = minTokensOutInput.value;

            if (!usdcAmountStr || parseFloat(usdcAmountStr) <= 0 || !minTokensOut || minTokensOut === '0') {
                return showStatus('Please enter a valid USDC amount and ensure estimate is calculated.', 'error');
            }

            const usdcAmount = parseUnits(usdcAmountStr, Number(usdcDecimals));
             if (usdcAmount === null) return;
            const minTokensBigInt = BigInt(minTokensOut);

            try {
                 const allowance = await usdcContract.allowance(userAddress, contractAddress);
                 if (allowance < usdcAmount) {
                      buyButton.disabled = true;
                     return showStatus('Insufficient USDC allowance. Please approve USDC first.', 'error');
                 }
                 buyButton.disabled = false;
            } catch (error) {
                 console.error("Error checking allowance:", error);
                 return showStatus('Could not check USDC allowance.', 'error');
            }


            setLoading(buyButton, true, 'Buy MTYLD');
            showStatus('Sending buy transaction...');

            try {
                const tx = await mtyldContract.buyTokens(usdcAmount, minTokensBigInt);
                showStatus('Buy transaction sent. Waiting for confirmation...', 'info');
                const receipt = await tx.wait();
                 console.log("Buy Receipt:", receipt);
                showStatus('Successfully bought MTYLD!', 'success');
                buyForm.reset();
                estimatedMtyldSpan.textContent = '0.00';
                minTokensOutInput.value = '0';
                buyButton.disabled = true;
                await updateWalletInfo();
                await updateProtocolInfo();
                // We refetch all orders on mint/payout, maybe refresh here too if needed?
                // await fetchAndStoreAllWorkOrders();
            } catch (error) {
                console.error("Buy failed:", error);
                 showStatus(`Buy transaction failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
            } finally {
                setLoading(buyButton, false, 'Buy MTYLD');
            }
        }

        async function handleRedeemTokens(event) {
            event.preventDefault();
            if (!mtyldContract || !signer) return showStatus('Please connect wallet first.', 'error');

            const mtyldAmountStr = redeemMtyldAmountInput.value;
            const minUsdcOut = minUsdcOutInput.value;

            if (!mtyldAmountStr || parseFloat(mtyldAmountStr) <= 0 || !minUsdcOut || minUsdcOut === '0') {
                return showStatus('Please enter a valid MTYLD amount and ensure estimate is calculated.', 'error');
            }

            const mtyldAmount = parseUnits(mtyldAmountStr, mtyldDecimals);
             if (mtyldAmount === null) return;
            const minUsdcBigInt = BigInt(minUsdcOut);

            const balance = await mtyldContract.balanceOf(userAddress);
             if (balance < mtyldAmount) {
                  return showStatus('Insufficient MTYLD balance.', 'error');
             }

            setLoading(redeemButton, true, 'Redeem MTYLD');
            showStatus('Sending redeem transaction...');

            try {
                const tx = await mtyldContract.redeemTokens(mtyldAmount, minUsdcBigInt);
                showStatus('Redeem transaction sent. Waiting for confirmation...', 'info');
                const receipt = await tx.wait();
                 console.log("Redeem Receipt:", receipt);
                showStatus('Successfully redeemed MTYLD for USDC!', 'success');
                redeemForm.reset();
                estimatedUsdcSpan.textContent = '0.00';
                minUsdcOutInput.value = '0';
                await updateWalletInfo();
                await updateProtocolInfo();
                // await fetchAndStoreAllWorkOrders(); // Refresh potentially?
            } catch (error) {
                console.error("Redeem failed:", error);
                 showStatus(`Redeem transaction failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
            } finally {
                setLoading(redeemButton, false, 'Redeem MTYLD');
            }
        }

        // --- Work Order Display & Filtering Logic ---

        // Fetch ALL orders and store them
        async function fetchAndStoreAllWorkOrders() {
            if (!mtyldContract) return;
            workOrdersTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-secondary">Fetching all work orders...</td></tr>';
            allWorkOrders = []; // Clear existing
            availableYears.clear(); // Clear existing years

            try {
                const nextId = await mtyldContract.nextWorkOrderId();
                if (nextId <= 1n) {
                    workOrdersTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-secondary">No work orders found.</td></tr>';
                    populateYearFilter(); // Populate even if empty
                    return;
                }

                const fetchPromises = [];
                // Fetch in reverse order (newest first)
                for (let i = nextId - 1n; i >= 1n; i--) {
                    fetchPromises.push(
                        mtyldContract.workOrders(i).then(order => {
                             if (order && order.id !== 0n) {
                                  const { dateStr, month, year } = formatDate(order.createdAt);
                                  if (year !== -1) availableYears.add(year); // Collect years
                                 // Store order data with processed date info
                                  return {
                                       id: order.id.toString(), // Store as string for easier filtering
                                       description: order.description,
                                       grossYield: order.grossYield,
                                       reserveAmount: order.reserveAmount,
                                       tokensIssued: order.tokensIssued,
                                       isActive: order.isActive,
                                       isPaid: order.isPaid,
                                       createdAt: order.createdAt, // Keep original timestamp
                                       createdDateStr: dateStr,
                                       createdMonth: month, // 0-11
                                       createdYear: year
                                  };
                             }
                             return null; // Handle potential empty slots or errors
                        }).catch(e => {
                             console.warn(`Could not fetch order ${i}:`, e);
                             return null;
                        })
                    );
                }

                const fetchedOrders = await Promise.all(fetchPromises);
                // Filter out nulls and sort by ID descending (which should be chronological descending)
                allWorkOrders = fetchedOrders.filter(order => order !== null).sort((a, b) => parseInt(b.id) - parseInt(a.id));

                populateYearFilter(); // Populate year dropdown
                filterAndRenderOrders(); // Render initially with "All" filters

            } catch (error) {
                console.error("Error fetching all work orders:", error);
                workOrdersTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-red-400">Error fetching work orders.</td></tr>';
                populateYearFilter(); // Still try to populate filter
            }
        }

        // Populate the year filter dropdown
        function populateYearFilter() {
            filterYearSelect.innerHTML = '<option value="all">All Years</option>'; // Reset
             const years = Array.from(availableYears).sort((a, b) => b - a); // Sort descending
             years.forEach(year => {
                  const option = document.createElement('option');
                  option.value = year;
                  option.textContent = year;
                  filterYearSelect.appendChild(option);
             });
        }


        // Filter and render the stored orders
        function filterAndRenderOrders() {
            const selectedMonth = filterMonthSelect.value; // "all" or "0"-"11"
            const selectedYear = filterYearSelect.value;   // "all" or year number

            const filteredOrders = allWorkOrders.filter(order => {
                const monthMatch = selectedMonth === 'all' || order.createdMonth == selectedMonth; // Use == for string/number comparison
                const yearMatch = selectedYear === 'all' || order.createdYear == selectedYear;
                return monthMatch && yearMatch;
            });

            renderWorkOrdersTable(filteredOrders);
        }

        // Render the table with the provided orders
        function renderWorkOrdersTable(ordersToRender) {
             workOrdersTableBody.innerHTML = ''; // Clear existing rows

             if (ordersToRender.length === 0) {
                  workOrdersTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-secondary">No work orders match the selected filters.</td></tr>';
                  return;
             }

             ordersToRender.forEach(order => {
                 const row = workOrdersTableBody.insertRow();
                 row.innerHTML = `
                     <td>${order.id}</td>
                     <td class="max-w-xs truncate" title="${order.description}">${order.description}</td>
                     <td>${parseFloat(formatUnits(order.grossYield, Number(usdcDecimals))).toFixed(2)}</td>
                     <td>${parseFloat(formatUnits(order.reserveAmount, Number(usdcDecimals))).toFixed(2)}</td>
                     <td>${parseFloat(formatUnits(order.tokensIssued, mtyldDecimals)).toFixed(4)}</td>
                     <td>
                          ${order.isPaid ? '<span class="text-green-400 font-semibold">Paid</span>' : (order.isActive ? '<span class="text-yellow-400 font-semibold">Active</span>' : '<span class="text-red-400 font-semibold">Cancelled</span>')}
                     </td>
                     <td>${order.createdDateStr}</td>
                 `;
             });
         }


        // --- Admin Actions ---

        async function handleMintOrder(event) {
             event.preventDefault();
             if (!mtyldContract || !signer || !contractOwner || !userAddress || userAddress.toLowerCase() !== contractOwner.toLowerCase()) {
                  return showStatus("Admin action requires owner wallet connection.", "error");
             }

             const yieldStr = document.getElementById('mint-yield').value;
             const description = document.getElementById('mint-desc').value;
             const button = event.target.querySelector('button[type="submit"]');
             const originalText = 'Mint Order';

             if (!yieldStr || parseFloat(yieldStr) <= 0 || !description) {
                  return showStatus('Please provide a valid gross yield and description.', 'error');
             }

             const grossYield = parseUnits(yieldStr, Number(usdcDecimals));
             if (grossYield === null) return;

             setLoading(button, true, originalText);
             showStatus('Sending mint work order transaction...');

             try {
                 const tx = await mtyldContract.mintFromWorkOrder(grossYield, description);
                  showStatus('Mint transaction sent. Waiting for confirmation...', 'info');
                 const receipt = await tx.wait();
                 console.log("Mint Receipt:", receipt);

                 let newOrderId = 'N/A';
                  if(receipt && receipt.logs) {
                       const mintEventInterface = new ethers.Interface(contractABI);
                       for (const log of receipt.logs) {
                            if (log.topics && log.data && log.address.toLowerCase() === contractAddress.toLowerCase()) {
                                try {
                                    const parsedLog = mintEventInterface.parseLog({ topics: [...log.topics], data: log.data });
                                    if (parsedLog && parsedLog.name === "WorkOrderMinted") {
                                        newOrderId = parsedLog.args.workOrderId.toString();
                                        break;
                                    }
                                } catch (e) { console.warn("Could not parse log:", log, e); }
                            }
                       }
                  }

                 showStatus(`Work order #${newOrderId} minted successfully!`, 'success');
                 mintOrderForm.reset();
                 await updateProtocolInfo();
                 await fetchAndStoreAllWorkOrders(); // Refresh all orders and filters
             } catch (error) {
                  console.error("Mint failed:", error);
                  showStatus(`Mint transaction failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
             } finally {
                  setLoading(button, false, originalText);
             }
         }


        async function handlePayoutOrder(event) {
             event.preventDefault();
             if (!mtyldContract || !signer || !contractOwner || !userAddress || userAddress.toLowerCase() !== contractOwner.toLowerCase()) {
                  return showStatus("Admin action requires owner wallet connection.", "error");
             }

             const orderIdStr = document.getElementById('payout-id').value;
             const amountStr = document.getElementById('payout-amount').value;
             const button = event.target.querySelector('button[type="submit"]');
             const originalText = 'Submit Payout';

              if (!orderIdStr || parseInt(orderIdStr) < 1 || !amountStr || parseFloat(amountStr) <= 0) {
                   return showStatus('Please provide a valid Work Order ID and Payout Amount.', 'error');
              }

             const orderId = BigInt(orderIdStr);
             const payoutAmount = parseUnits(amountStr, Number(usdcDecimals));
              if (payoutAmount === null) return;

              try {
                   const allowance = await usdcContract.allowance(userAddress, contractAddress);
                   if (allowance < payoutAmount) {
                        return showStatus('Insufficient USDC allowance from owner wallet. Please approve USDC first.', 'error');
                   }
              } catch (error) {
                   console.error("Error checking payout allowance:", error);
                   return showStatus('Could not check owner USDC allowance.', 'error');
              }


             setLoading(button, true, originalText);
             showStatus(`Sending payout transaction for order #${orderId}...`);

             try {
                 const tx = await mtyldContract.payoutWorkOrder(orderId, payoutAmount);
                 showStatus('Payout transaction sent. Waiting for confirmation...', 'info');
                 const receipt = await tx.wait();
                  console.log("Payout Receipt:", receipt);
                 showStatus(`Work order #${orderId} paid out successfully!`, 'success');
                 payoutOrderForm.reset();
                 await updateProtocolInfo();
                 await updateWalletInfo();
                 await fetchAndStoreAllWorkOrders(); // Refresh all orders
             } catch (error) {
                 console.error("Payout failed:", error);
                 showStatus(`Payout transaction failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
             } finally {
                 setLoading(button, false, originalText);
             }
         }


        async function handleCancelOrder(event) {
             event.preventDefault();
              if (!mtyldContract || !signer || !contractOwner || !userAddress || userAddress.toLowerCase() !== contractOwner.toLowerCase()) {
                  return showStatus("Admin action requires owner wallet connection.", "error");
             }

              const orderIdStr = document.getElementById('cancel-id').value;
              const button = event.target.querySelector('button[type="submit"]');
              const originalText = 'Cancel Order';

              if (!orderIdStr || parseInt(orderIdStr) < 1) {
                   return showStatus('Please provide a valid Work Order ID.', 'error');
              }
              const orderId = BigInt(orderIdStr);

              if (!confirm(`Are you sure you want to cancel Work Order #${orderId}? This cannot be undone.`)) {
                   return;
              }


             setLoading(button, true, originalText);
             showStatus(`Sending cancel transaction for order #${orderId}...`);

             try {
                 const tx = await mtyldContract.cancelWorkOrder(orderId);
                 showStatus('Cancel transaction sent. Waiting for confirmation...', 'info');
                 const receipt = await tx.wait();
                  console.log("Cancel Receipt:", receipt);
                 showStatus(`Work order #${orderId} cancelled successfully!`, 'success');
                 cancelOrderForm.reset();
                 await fetchAndStoreAllWorkOrders(); // Refresh orders
             } catch (error) {
                 console.error("Cancel failed:", error);
                 showStatus(`Cancel transaction failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
             } finally {
                 setLoading(button, false, originalText);
             }
         }


        async function handleSetFee(event) {
             event.preventDefault();
              if (!mtyldContract || !signer || !contractOwner || !userAddress || userAddress.toLowerCase() !== contractOwner.toLowerCase()) {
                  return showStatus("Admin action requires owner wallet connection.", "error");
             }

             const feeStr = document.getElementById('new-fee').value;
             const button = event.target.querySelector('button[type="submit"]');
             const originalText = 'Update Fee';

              const fee = parseFloat(feeStr);
             if (isNaN(fee) || fee < 0 || fee > 20) {
                 return showStatus('Please enter a valid fee percentage between 0 and 20.', 'error');
             }
              const feeBigInt = BigInt(Math.round(fee));


             setLoading(button, true, originalText);
             showStatus(`Setting redemption fee to ${fee}%...`);

             try {
                 const tx = await mtyldContract.setRedemptionFee(feeBigInt);
                 showStatus('Set fee transaction sent. Waiting for confirmation...', 'info');
                 const receipt = await tx.wait();
                  console.log("Set Fee Receipt:", receipt);
                 showStatus(`Redemption fee updated to ${fee}% successfully!`, 'success');
                 setFeeForm.reset();
                 await updateAdminInfo();
                 await updateProtocolInfo();
             } catch (error) {
                  console.error("Set fee failed:", error);
                  showStatus(`Set fee transaction failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
             } finally {
                  setLoading(button, false, originalText);
             }
         }


        async function handleWithdrawFees() {
             if (!mtyldContract || !signer || !contractOwner || !userAddress || userAddress.toLowerCase() !== contractOwner.toLowerCase()) {
                  return showStatus("Admin action requires owner wallet connection.", "error");
             }

             const button = withdrawFeesButton;
             const originalText = 'Withdraw All Fees';

             const feesAvailable = await mtyldContract.collectedFees();
             if (feesAvailable === 0n) {
                  return showStatus('No fees available to withdraw.', 'info');
             }

             setLoading(button, true, originalText);
             showStatus(`Withdrawing ${formatUnits(feesAvailable, Number(usdcDecimals))} USDC in fees...`);

             try {
                 const tx = await mtyldContract.withdrawFees();
                 showStatus('Withdraw fees transaction sent. Waiting for confirmation...', 'info');
                 const receipt = await tx.wait();
                  console.log("Withdraw Fees Receipt:", receipt);
                 showStatus('Fees withdrawn successfully!', 'success');
                 await updateAdminInfo();
                 await updateWalletInfo();
             } catch (error) {
                 console.error("Withdraw fees failed:", error);
                 showStatus(`Withdraw fees transaction failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
             } finally {
                 setLoading(button, false, originalText);
             }
         }

        async function handleEmergencyWithdraw(event) {
             event.preventDefault();
              if (!mtyldContract || !signer || !contractOwner || !userAddress || userAddress.toLowerCase() !== contractOwner.toLowerCase()) {
                  return showStatus("Admin action requires owner wallet connection.", "error");
             }

             const tokenAddress = document.getElementById('emergency-token').value;
             const toAddress = document.getElementById('emergency-to').value;
             const amountStr = document.getElementById('emergency-amount').value;
             const button = event.target.querySelector('button[type="submit"]');
             const originalText = 'Withdraw Token';

              let amount;
              try {
                   amount = BigInt(amountStr);
                   if (amount <= 0n) throw new Error("Amount must be positive");
              } catch {
                   return showStatus('Please provide a valid, positive amount in raw units.', 'error');
              }

             if (!ethers.isAddress(tokenAddress) || !ethers.isAddress(toAddress)) {
                  return showStatus('Please provide valid token and recipient addresses.', 'error');
             }


             setLoading(button, true, originalText);
             showStatus(`Attempting emergency withdraw of token ${shortenAddress(tokenAddress)}...`);

             try {
                  const tx = await mtyldContract.emergencyWithdraw(tokenAddress, toAddress, amount);
                  showStatus('Emergency withdraw transaction sent. Waiting for confirmation...', 'info');
                  const receipt = await tx.wait();
                   console.log("Emergency Withdraw Receipt:", receipt);
                  showStatus('Emergency withdraw successful!', 'success');
                  emergencyWithdrawForm.reset();
             } catch (error) {
                  console.error("Emergency withdraw failed:", error);
                  showStatus(`Emergency withdraw failed: ${error?.data?.message || error?.reason || error.message || error}`, 'error');
             } finally {
                  setLoading(button, false, originalText);
             }
        }


        // --- Event Listeners Setup ---
         function setupEventListeners() {
            if (window.eventListenersAttached) return;

             // Input listeners for estimates
             buyUsdcAmountInput.addEventListener('input', updateBuyEstimate);
             buySlippageSelect.addEventListener('change', updateBuyEstimate);
             redeemMtyldAmountInput.addEventListener('input', updateRedeemEstimate);
             redeemSlippageSelect.addEventListener('change', updateRedeemEstimate);

             // Button listeners
             approveUsdcButton.addEventListener('click', () => handleApproveUSDC(false));
             buyForm.addEventListener('submit', handleBuyTokens);
             redeemForm.addEventListener('submit', handleRedeemTokens);

            // Filter listeners
            filterMonthSelect.addEventListener('change', filterAndRenderOrders);
            filterYearSelect.addEventListener('change', filterAndRenderOrders);


             // Admin listeners
             if (adminApproveUsdcButton) adminApproveUsdcButton.addEventListener('click', () => handleApproveUSDC(true));
             if (mintOrderForm) mintOrderForm.addEventListener('submit', handleMintOrder);
             if (payoutOrderForm) payoutOrderForm.addEventListener('submit', handlePayoutOrder);
             if (cancelOrderForm) cancelOrderForm.addEventListener('submit', handleCancelOrder);
             if (setFeeForm) setFeeForm.addEventListener('submit', handleSetFee);
             if (withdrawFeesButton) withdrawFeesButton.addEventListener('click', handleWithdrawFees);
             if (emergencyWithdrawForm) emergencyWithdrawForm.addEventListener('submit', handleEmergencyWithdraw);

             // Work Orders (Load More is commented out)
             // if (loadMoreOrdersButton) loadMoreOrdersButton.addEventListener('click', () => fetchWorkOrders(false));


             // MetaMask / Wallet Listeners
             if (window.ethereum && window.ethereum.on) {
                 window.ethereum.on('accountsChanged', (accounts) => {
                     console.log('Accounts changed:', accounts);
                     if (accounts.length === 0) {
                         // Reset state on disconnect
                         userAddress = null; signer = null; provider = null;
                         contractOwner = null; allWorkOrders = []; availableYears.clear();
                         walletInfoDiv.classList.add('hidden');
                         connectButton.textContent = 'Connect Wallet';
                         connectButton.disabled = false;
                         adminPanelDiv.classList.add('hidden');
                         workOrdersTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-secondary">Connect wallet to view orders.</td></tr>';
                         populateYearFilter(); // Clear year filter
                         showStatus('Wallet disconnected.', 'info');
                         document.getElementById('usdc-balance').textContent = 'Disconnected';
                         document.getElementById('mtyld-balance').textContent = 'Disconnected';
                         buyUsdcBalanceSpan.textContent = '--';
                         redeemMtyldBalanceSpan.textContent = '--';

                     } else if (!userAddress || accounts[0].toLowerCase() !== userAddress.toLowerCase()) {
                          // Connect or switch account
                          connectWallet();
                     }
                 });

                 window.ethereum.on('chainChanged', (chainId) => {
                     console.log('Network changed to:', chainId);
                      if (chainId !== arbitrumChainId) {
                           showStatus('Incorrect network detected. Please switch back to Arbitrum One in MetaMask.', 'error');
                           userAddress = null; signer = null; provider = null;
                           contractOwner = null; allWorkOrders = []; availableYears.clear();
                           walletInfoDiv.classList.add('hidden');
                           connectButton.textContent = 'Wrong Network';
                           connectButton.disabled = true;
                           adminPanelDiv.classList.add('hidden');
                           workOrdersTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-secondary">Switch to Arbitrum One.</td></tr>';
                           populateYearFilter();
                           tokenNameSpan.textContent = 'Wrong Network';
                      } else {
                           // Switched back to correct network
                           showStatus('Network changed back to Arbitrum One. Please reconnect wallet or refresh.', 'info');
                           connectButton.textContent = 'Connect Wallet';
                           connectButton.disabled = false;
                           // Optionally auto-reconnect or just prompt user
                           // connectWallet(); // Could cause loops if MetaMask prompts repeatedly
                      }
                 });
             } else {
                  console.warn("MetaMask event listeners not available.");
             }

             window.eventListenersAttached = true;
         }


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
             connectButton.addEventListener('click', connectWallet);
             // Initial state: prompt connect
             workOrdersTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-secondary">Connect wallet to view orders.</td></tr>';
             populateYearFilter(); // Populate with defaults initially

        });

    </script>
</body>
</html>

