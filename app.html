<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTYLD Token dApp</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.1/ethers.umd.min.js"
        integrity="sha512-4USGSRDqc/uE/EYD2rLdIuLwUo3o/3M8KiUuHDB2CHJmVM/P8Z8iEcVvr7s3qVOs3i5jNfNfBvQ2mQ22a3QabA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2 {
            color: #1a1a1a;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }
        button {
            background-color: #007aff;
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #c0c0c0;
            cursor: not-allowed;
        }
        #app {
            display: none; /* Hidden by default, shown after connect */
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .section {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }
        input[type="text"] {
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 6px;
            margin-right: 10px;
            width: 250px;
        }
        #log {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 8px;
            font-family: "Courier New", Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
        }
        .info-grid {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
        }
        .info-grid span:first-child {
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>MTYLD Token dApp</h1>
    <p>Connect your wallet to interact with the contract.</p>

    <button id="connectButton">Connect Wallet</button>

    <div id="app">
        
        <div class="section">
            <h2>Account & Contract Info</h2>
            <div id="info" class="info-grid">
                <span>Status:</span> <span id="status">Disconnected</span>
                <span>Account:</span> <span id="account">N/A</span>
                <span>Token Name:</span> <span id="tokenName">N/A</span>
                <span>Token Symbol:</span> <span id="tokenSymbol">N/A</span>
                <span>Payment Token:</span> <span id="paymentToken">N/A</span>
            </div>
        </div>

        <div class="section">
            <h2>Your Balances</h2>
            <div id="balances" class="info-grid">
                <span>USDC Balance:</span> <span id="usdcBalance">N/A</span>
                <span>MTYLD Balance:</span> <span id="mtyldBalance">N/A</span>
            </div>
            <br>
            <button id="refreshButton">Refresh Balances</button>
        </div>

        <div class="section">
            <h2>Buy Tokens (with USDC)</h2>
            <p>Enter the amount of USDC you want to spend.</p>
            <div>
                <input type="text" id="buyAmount" placeholder="Amount of USDC">
                <button id="buyQuoteButton">Get Quote</button>
            </div>
            <p>You will get (approx): <strong id="buyQuote">0</strong> MTYLD</p>
            <br>
            <button id="approveButton">1. Approve USDC</button>
            <button id="buyButton">2. Buy Tokens</button>
        </div>

        <div class="section">
            <h2>Redeem Tokens (for USDC)</h2>
            <p>Enter the amount of MTYLD you want to redeem.</p>
            <div>
                <input type="text" id="redeemAmount" placeholder="Amount of MTYLD">
                <button id="redeemQuoteButton">Get Quote</button>
            </div>
            <p>You will get (approx): <strong id="redeemQuote">0</strong> USDC</p>
            <br>
            <button id="redeemButton">Redeem Tokens</button>
        </div>

    </div>

    <h2>Logs</h2>
    <pre id="log">Awaiting connection...</pre>

    <script>
        // --- Contract Constants ---
        // This is the address of your main MTYLD token contract
        const contractAddress = "0xae2C05f01DBCC6C8AF40EbFA3339Af10dbECdFD0";
        
        // This is the ABI you provided
        const contractAbi = [{"inputs":[{"internalType":"address","name":"initialOwner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressCallToNonContract","type":"error"},{"inputs":[],"name":"AddressEmptyRevertData","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"burner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Burn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"FeeChangeExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newFeePercentage","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"proposedAt","type":"uint256"}],"name":"FeeChangeProposed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"FeesWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"proposalId","type":"uint256"}],"name":"MintExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"proposalId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"grossYield","type":"uint256"},{"indexed":false,"internalType":"string","name":"description","type":"string"},{"indexed":false,"internalType":"uint256","name":"proposedAt","type":"uint256"}],"name":"MintProposed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"RedemptionFeeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"reserveAmount","type":"uint256"}],"name":"ReserveFunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"holder","type":"address"},{"indexed":false,"internalType":"uint256","name":"mtyldAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdcAmount","type":"uint256"}],"name":"TokensRedeemed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"}],"name":"WorkOrderCancelled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"grossYield","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"tokenizedValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"tokensIssued","type":"uint256"},{"indexed":false,"internalType":"string","name":"description","type":"string"}],"name":"WorkOrderMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"workOrderId","type":"uint256"},{"indexed":true,"internalType":"address","name":"payer","type":"address"},{"indexed":false,"internalType":"uint256","name":"payoutAmount","type":"uint256"}],"name":"WorkOrderPaid","type":"event"},{"inputs":[],"name":"PROPOSAL_DELAY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"RESERVE_PERCENTAGE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TOKENIZATION_PERCENTAGE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type."type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"availableTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdcAmount","type":"uint256"},{"internalType":"uint256","name":"minTokensOut","type":"uint256"}],"name":"buyTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"workOrderId","type":"uint256"}],"name":"cancelWorkOrder","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"collectedFees","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractPaymentTokenBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type_:"uint256"}],"name":"emergencyWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"executeFeeChange","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"proposalId","type":"uint256"}],"name":"executeMint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"mtyldAmount","type":"uint256"}],"name":"getRedemptionValue","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdcAmount","type":"uint256"}],"name":"getTokensForUSDC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"startId","type":"uint256"},{"internalType":"uint256","name":"endId","type":"uint256"}],"name":"getWorkOrderRange","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"grossYield","type":"uint256"},{"internalType":"uint256","name":"tokenizedValue","type":"uint256"},{"internalType":"uint256","name":"reserveAmount","type":"uint256"},{"internalType":"uint256","name":"tokensIssued","type":"uint256"},{"internalType":"bool","name":"isActive","type":"bool"},{"internalType":"bool","name":"isPaid","type":"bool"},{"internalType":"string","name":"description","type":"string"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"internalType":"struct MechanicalTempYieldToken.WorkOrder[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextProposalId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextWorkOrderId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type.type":"function"},{"inputs":[],Name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"sHLO"}],"NoteiableView","typeAccess-key": "function"}, {"inputs": [], "name": "paymentToken",Functionsim," "outputs": [
StreamTypeInternal": "contract IERC20", "name": "", "type": "address"}], "stateMutability": "view", "type": "function"}, {"inputs": [{"internalType": "uint256", "name": "workOrderId", "type": "uint256"}, {"internalType": "uint256", "name": "payoutAmount", "type": "uint256"}], "name": "payoutWorkOrder", "outputs": [], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "name": "pendingFeeChange", "outputs": [{"internalType": "uint256", "name": "newFeePercentage", "type": "uint256"}, {"internalType": "uint256", "name":NotImplementedError":"proposedAt", "type": "uint256"}, {"internalType": "bool", "name": "exists", "type": "bool"}], "stateMutability": "view", "type": "function"}, {"inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "name": "pendingMints", "outputs": [{"internalType": "uint256", "name": "grossYield", "type": "uint256"}, {"internalType": "string", "name": "description", "type": "string"}, {"internalType": "uint256", "name": "proposedAt", "type": "uint256"}, {"internalType": "bool", "name": "exists", "type":It's bool}], "stateMutability": "view", "type": "function"}, {"inputs": [{"internalType": "uint256", "name": "newFeePercentage", "type": "uint256"}], "name": "proposeFeeChange", "outputs": [], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [{"internalType": "uint256", "name": "grossYield", "type": "uint256"}, {"internalType": "string", "name": "description", "type": "string"}], "name": "proposeMint", "outputs": [{"internalType": "uint256", "name": "", "type":F:"uint256"}], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [{"internalType": "uint256", "name": "mtyldAmount", "type": "uint256"}, {"internalType":Internal": "uint256", "name": "minUsdcOut", "type": "uint256"}], "name": "redeemTokens", "outputs": [], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "name": "redemptionFeePercentage", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"}, {"inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "name": "symbol", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"}, {"inputs": [], "name": "totalReserveFund", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"}, {"inputs": [], "name": "totalSupply", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"}, {"inputs": [{"internalType": "address", "name": "to", "type": "address"}, {"internalType": "uint256", "name": "value", "type": "uint256"}], "name": "transfer", "outputs": [{"internalType": "bool", "name": "", "type": "bool"}], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [{"internalType": "address", "name": "from", "type": "address"}, {"internalType": "address", "name": "to", "type": "address"}, {"internalType": "uint256", "name": "value", "type": "uint256"}], "name": "transferFrom", "outputs": [{"internalType": "bool", "name": "", "type": "bool"}], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "name": "unpause", "outputs": [], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "name": "withdrawFees", "outputs": [], "stateMutability": "nonpayable", "type": "function"}, {"inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "name": "workOrders", "outputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}, {"internalType": "uint256", "name": "grossYield", "type": "uint256"}, {"internalType": "uint256", "name": "tokenizedValue", "type": "uint256"}, {"internalType": "uint256", "name": "reserveAmount", "type": "uint256"}, {"internalType": "uint256", "name": "tokensIssued", "type": "uint256"}, {"internalType": "bool", "name": "isActive", "type": "bool"}, {"internalType": "bool", "name": "isPaid", "type": "bool"}, {"internalType": "string", "name": "description", "type": "string"}, {"internalType": "uint256", "name": "createdAt", "type": "uint256"}], "stateMutability": "view", "type": "function"}];
        
        // We need a minimal ABI for the ERC20 payment token (USDC)
        // We only need `approve`, `balanceOf`, and `decimals`
        const erc20Abi = [
            "function approve(address spender, uint256 amount) returns (bool)",
            "function balanceOf(address account) view returns (uint256)",
            "function decimals() view returns (uint8)"
        ];

        // --- Global Variables ---
        let provider;
        let signer;
        let userAddress;
        let contract;
        let paymentTokenContract;
        let paymentTokenAddress;
        let paymentTokenDecimals;
        let mtyldTokenDecimals;

        // --- DOM Elements ---
        const connectButton = document.getElementById('connectButton');
        const appDiv = document.getElementById('app');
        const logEl = document.getElementById('log');

        const statusEl = document.getElementById('status');
        const accountEl = document.getElementById('account');
        const tokenNameEl = document.getElementById('tokenName');
        const tokenSymbolEl = document.getElementById('tokenSymbol');
        const paymentTokenEl = document.getElementById('paymentToken');
        
        const usdcBalanceEl = document.getElementById('usdcBalance');
        const mtyldBalanceEl = document.getElementById('mtyldBalance');
        const refreshButton = document.getElementById('refreshButton');
        
        const buyAmountInput = document.getElementById('buyAmount');
        const buyQuoteButton = document.getElementById('buyQuoteButton');
        const buyQuoteEl = document.getElementById('buyQuote');
        const approveButton = document.getElementById('approveButton');
        const buyButton = document.getElementById('buyButton');

        const redeemAmountInput = document.getElementById('redeemAmount');
        const redeemQuoteButton = document.getElementById('redeemQuoteButton');
        const redeemQuoteEl = document.getElementById('redeemQuote');
        const redeemButton = document.getElementById('redeemButton');


        // --- Event Listeners ---
        connectButton.onclick = connectWallet;
        refreshButton.onclick = loadUserBalances;
        
        buyQuoteButton.onclick = getBuyQuote;
        approveButton.onclick = approveUsdc;
        buyButton.onclick = buyTokens;

        redeemQuoteButton.onclick = getRedeemQuote;
        redeemButton.onclick = redeemTokens;


        // --- Core Functions ---

        /**
         * Logs a message to the on-screen console.
         */
        function log(message) {
            console.log(message);
            logEl.textContent = `${new Date().toLocaleTimeString()}: ${message}\n` + logEl.textContent;
        }

        /**
         * Connects to the user's wallet (e.g., MetaMask).
         */
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                log('Error: MetaMask is not installed. Please install it to use this app.');
                return;
            }

            try {
                log('Connecting to wallet...');
                // 1. Create a new ethers provider
                // We use BrowserProvider to connect to the wallet in the browser
                provider = new ethers.BrowserProvider(window.ethereum);
                
                // 2. Get the user's signer object
                // This will prompt the user to connect their wallet
                signer = await provider.getSigner();
                userAddress = await signer.getAddress();

                // 3. Create the main contract instance
                contract = new ethers.Contract(contractAddress, contractAbi, signer);

                log('Wallet connected successfully.');
                statusEl.textContent = 'Connected';
                accountEl.textContent = userAddress;

                // 4. Hide connect button, show the main app
                connectButton.style.display = 'none';
                appDiv.style.display = 'block';

                // 5. Load initial data from the contract
                await loadContractData();
                
            } catch (err) {
                log(`Error connecting wallet: ${err.message || err}`);
            }
        }

        /**
         * Loads static data from the contract (name, symbol, etc.)
         * and sets up the payment token contract.
         */
        async function loadContractData() {
            try {
                log('Loading contract data...');
                // Parallel requests for read-only data
                const [name, symbol, mainDecimals, pTokenAddress] = await Promise.all([
                    contract.name(),
                    contract.symbol(),
                    contract.decimals(),
                    contract.paymentToken() // Get the address of the payment token (USDC)
                ]);

                tokenNameEl.textContent = name;
                tokenSymbolEl.textContent = symbol;
                paymentTokenEl.textContent = pTokenAddress;
                
                mtyldTokenDecimals = Number(mainDecimals); // Store MTYLD decimals
                paymentTokenAddress = pTokenAddress;

                log(`Contract: ${name} (${symbol})`);
                log(`Payment Token Address: ${paymentTokenAddress}`);

                // Now, create a contract instance for the Payment Token (USDC)
                paymentTokenContract = new ethers.Contract(paymentTokenAddress, erc20Abi, signer);
                
                // Get decimals for the payment token
                paymentTokenDecimals = Number(await paymentTokenContract.decimals());
                log(`Payment Token Decimals: ${paymentTokenDecimals}`);
                
                // Now that we have all contract info, load user balances
                await loadUserBalances();
                
            } catch (err) {
                log(`Error loading contract data: ${err.message || err}`);
            }
        }

        /**
         * Fetches and updates the user's MTYLD and USDC balances.
         */
        async function loadUserBalances() {
            try {
                log('Refreshing user balances...');
                
                // Get MTYLD balance (from our main contract)
                const mtyldBalanceRaw = await contract.balanceOf(userAddress);
                const mtyldBalanceFormatted = ethers.formatUnits(mtyldBalanceRaw, mtyldTokenDecimals);
                mtyldBalanceEl.textContent = `${mtyldBalanceFormatted} MTYLD`;

                // Get USDC balance (from the payment token contract)
                const usdcBalanceRaw = await paymentTokenContract.balanceOf(userAddress);
                const usdcBalanceFormatted = ethers.formatUnits(usdcBalanceRaw, paymentTokenDecimals);
                usdcBalanceEl.textContent = `${usdcBalanceFormatted} USDC`;
                
                log('Balances updated.');
            } catch (err) {
                log(`Error refreshing balances: ${err.message || err}`);
            }
        }

        // --- Quote Functions ---

        /**
         * Gets a quote for buying tokens.
         */
        async function getBuyQuote() {
            const amountIn = buyAmountInput.value;
            if (!amountIn || isNaN(amountIn)) {
                log("Please enter a valid USDC amount.");
                return;
            }

            try {
                // Convert the human-readable amount (e.g., 100) to the smallest unit (e.g., 100000000)
                const usdcAmountWei = ethers.parseUnits(amountIn, paymentTokenDecimals);
                
                log(`Getting quote for ${amountIn} USDC...`);
                
                // Call the read-only view function
                const tokensOutWei = await contract.getTokensForUSDC(usdcAmountWei);
                
                // Convert the result back to a human-readable format
                const tokensOutFormatted = ethers.formatUnits(tokensOutWei, mtyldTokenDecimals);
                
                buyQuoteEl.textContent = tokensOutFormatted;
                log(`Quote received: ${tokensOutFormatted} MTYLD`);
                
            } catch (err) {
                log(`Error getting buy quote: ${err.message || err}`);
                buyQuoteEl.textContent = "Error";
            }
        }

        /**
         * Gets a quote for redeeming tokens.
         */
        async function getRedeemQuote() {
            const amountIn = redeemAmountInput.value;
            if (!amountIn || isNaN(amountIn)) {
                log("Please enter a valid MTYLD amount.");
                return;
            }

            try {
                // Convert the human-readable amount to the smallest unit
                const mtyldAmountWei = ethers.parseUnits(amountIn, mtyldTokenDecimals);
                
                log(`Getting quote for ${amountIn} MTYLD...`);
                
                // Call the read-only view function
                const usdcOutWei = await contract.getRedemptionValue(mtyldAmountWei);
                
                // Convert the result back to a human-readable format
                const usdcOutFormatted = ethers.formatUnits(usdcOutWei, paymentTokenDecimals);
                
                redeemQuoteEl.textContent = usdcOutFormatted;
                log(`Quote received: ${usdcOutFormatted} USDC`);

            } catch (err) {
                log(`Error getting redeem quote: ${err.message || err}`);
                redeemQuoteEl.textContent = "Error";
            }
        }

        // --- Write (Transaction) Functions ---

        /**
         * Approves the main contract to spend the user's USDC.
         */
        async function approveUsdc() {
            const amountIn = buyAmountInput.value;
            if (!amountIn || isNaN(amountIn)) {
                log("Please enter a valid USDC amount to approve.");
                return;
            }
            
            try {
                // Convert amount to Wei
                const usdcAmountWei = ethers.parseUnits(amountIn, paymentTokenDecimals);

                log(`Approving ${amountIn} USDC for spending by ${contractAddress}...`);
                
                // This is a transaction, so it returns a transaction object
                const tx = await paymentTokenContract.approve(contractAddress, usdcAmountWei);
                
                log(`Transaction sent... waiting for confirmation. Hash: ${tx.hash}`);
                approveButton.disabled = true;
                approveButton.textContent = "Approving...";
                
                // Wait for the transaction to be mined
                await tx.wait();

                log("Approval successful!");
                
            } catch (err) {
                log(`Approval failed: ${err.message || err}`);
            } finally {
                approveButton.disabled = false;
                approveButton.textContent = "1. Approve USDC";
            }
        }

        /**
         * Executes the token purchase.
         */
        async function buyTokens() {
            const amountIn = buyAmountInput.value;
            if (!amountIn || isNaN(amountIn)) {
                log("Please enter a valid USDC amount to buy with.");
                return;
            }

            try {
                // Convert amount to Wei
                const usdcAmountWei = ethers.parseUnits(amountIn, paymentTokenDecimals);
                
                // For minTokensOut, we'll just set it to 0 for this example.
                // In a real app, you'd use the quote + a "slippage" tolerance.
                const minTokensOut = 0;

                log(`Attempting to buy tokens with ${amountIn} USDC...`);
                buyButton.disabled = true;
                buyButton.textContent = "Buying...";
                
                // Call the buyTokens function on our main contract
                const tx = await contract.buyTokens(usdcAmountWei, minTokensOut);
                
                log(`Buy transaction sent... waiting for confirmation. Hash: ${tx.hash}`);
                
                // Wait for the transaction to be mined
                await tx.wait();

                log("Purchase successful!");
                
                // Refresh balances after the transaction
                await loadUserBalances();
                buyAmountInput.value = "";
                buyQuoteEl.textContent = "0";
                
            } catch (err) {
                log(`Buy failed: ${err.message || err}`);
            } finally {
                buyButton.disabled = false;
                buyButton.textContent = "2. Buy Tokens";
            }
        }

        /**
         * Executes the token redemption.
         */
        async function redeemTokens() {
            const amountIn = redeemAmountInput.value;
            if (!amountIn || isNaN(amountIn)) {
                log("Please enter a valid MTYLD amount to redeem.");
                return;
            }

            try {
                // Convert amount to Wei
                const mtyldAmountWei = ethers.parseUnits(amountIn, mtyldTokenDecimals);
                
                // For minUsdcOut, we'll set it to 0 for this example.
                const minUsdcOut = 0;

                log(`Attempting to redeem ${amountIn} MTYLD...`);
                redeemButton.disabled = true;
                redeemButton.textContent = "Redeeming...";

                // Call the redeemTokens function on our main contract
                // Note: No approval is needed here because the contract *is* the token
                // it can manage its own balances (e.g., burn from the caller).
                const tx = await contract.redeemTokens(mtyldAmountWei, minUsdcOut);
                
                log(`Redeem transaction sent... waiting for confirmation. Hash: ${tx.hash}`);
                
                // Wait for the transaction to be mined
                await tx.wait();
                
                log("Redemption successful!");

                // Refresh balances after the transaction
                await loadUserBalances();
                redeemAmountInput.value = "";
                redeemQuoteEl.textContent = "0";

            } catch (err) {
                log(`Redeem failed: ${err.message || err}`);
            } finally {
                redeemButton.disabled = false;
                redeemButton.textContent = "Redeem Tokens";
            }
        }
    </script>
</body>
</html>
